path: "/home/peter/my_projects/individual-gits/pr-groups/app/myImgAttributions.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/myImgAttributions.tsx
fileSize: 4264
replaced:
import { ImgAttribution } from "./_lib/ImgAttributions";

/*
                        { imgUrl: '/check-mark_5299035.png', attribution: 
                            <a href="https://www.freepik.com/icon/check-mark_5299035#fromView=search&page=2&position=63&uuid=a213ba3c-7c1f-4ffb-987d-a3f27fae4442">Icon by Ian June</a>
                        },
                        { imgUrl: '/copy_1621635.png', attribution: 
                            <a href="https://www.freepik.com/icon/copy_1621635#fromView=search&page=1&position=1&uuid=7742990b-36dc-4812-9450-ab42a0e5b87b">Icon by Freepik</a>
                        },
                        { imgUrl: '/cross_8995303.png', attribution: 
                            <a href="https://www.freepik.com/icon/cross_8995303#fromView=search&page=2&position=91&uuid=a9dd6062-9b81-43c5-bf5a-ea44908109c4">Icon by Maan Icons</a>
                        },
                        { imgUrl: '/edit_12000664.png', attribution: 
                            <a href="https://www.freepik.com/icon/edit_12000664#fromView=search&page=2&position=47&uuid=c237083f-91e4-4a1e-9a0d-563d40de6c2e">Icon by Mihimihi</a>
                        },
                        { imgUrl: '/thinking_982997.png', attribution: 
                            <a href="https://www.freepik.com/icon/thinking_982997">Icon by Freepik</a>
                        },
                        { imgUrl: '/square_14034302.png', attribution: 
                            <a href="https://www.freepik.com/icon/square_14034302#fromView=search&page=1&position=7&uuid=ebccda20-7e84-4c88-a3db-182ec9011a80">Icon by hqrloveq</a>
                        },
                        { imgUrl: '/information-point_72168.png', attribution: 
                            <a href="https://www.freepik.com/icon/information-point_72168#fromView=search&page=1&position=47&uuid=b9930744-8704-4a8e-b74f-54b33db1f21f">Icon by Freepik</a>
                        },
 
*/
export const myImgAttributions: ImgAttribution[] = [
    { imgUrl: '/check-mark_5299035.png', attribution: 
        <a href="https://www.freepik.com/icon/check-mark_5299035#fromView=search&page=2&position=63&uuid=a213ba3c-7c1f-4ffb-987d-a3f27fae4442">Icon by Ian June</a>
    },
    { imgUrl: '/copy_1621635.png', attribution: 
        <a href="https://www.freepik.com/icon/copy_1621635#fromView=search&page=1&position=1&uuid=7742990b-36dc-4812-9450-ab42a0e5b87b">Icon by Freepik</a>
    },
    { imgUrl: '/cross_8995303.png', attribution: 
        <a href="https://www.freepik.com/icon/cross_8995303#fromView=search&page=2&position=91&uuid=a9dd6062-9b81-43c5-bf5a-ea44908109c4">Icon by Maan Icons</a>
    },
    { imgUrl: '/edit_12000664.png', attribution: 
        <a href="https://www.freepik.com/icon/edit_12000664#fromView=search&page=2&position=47&uuid=c237083f-91e4-4a1e-9a0d-563d40de6c2e">Icon by Mihimihi</a>
    },
    { imgUrl: '/thinking_982997.png', attribution: 
        <a href="https://www.freepik.com/icon/thinking_982997">Icon by Freepik</a>
    },
    { imgUrl: '/square_14034302.png', attribution: 
        <a href="https://www.freepik.com/icon/square_14034302#fromView=search&page=1&position=7&uuid=ebccda20-7e84-4c88-a3db-182ec9011a80">Icon by hqrloveq</a>
    },
    { imgUrl: '/information-point_72168.png', attribution: 
        <a href="https://www.freepik.com/icon/information-point_72168#fromView=search&page=1&position=47&uuid=b9930744-8704-4a8e-b74f-54b33db1f21f">Icon by Freepik</a>
    },
    {
        imgUrl: '/archive_11294147.png',
        attribution: <a href="https://www.freepik.com/icon/archive_11294147#fromView=search&page=1&position=58&uuid=15edea8f-00f6-4415-9d87-b17d0a8913c0">Icon by Anggara</a>
    },
    {
        imgUrl: '/group-friends-jumping-top-hill.jpg',
        attribution: <a href="https://www.freepik.com/free-photo/group-friends-jumping-top-hill_10419965.htm#fromView=search&page=1&position=1&uuid=f8465827-f131-418a-9192-0f05b8dcce97">Image by wayhomestudio on Freepik</a>
    },
    {
        imgUrl: '/43702940_9078334.jpg',
        attribution: <a href="https://www.freepik.com/free-psd/medium-shot-friends-reunion-after-covid_43702940.htm#fromView=search&page=1&position=12&uuid=11a09d1c-f33f-4319-82b7-461f0dd5b8e5">Image by freepik</a>
    }
]

path: "/home/peter/my_projects/individual-gits/pr-groups/app/Privacy.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/Privacy.tsx
fileSize: 533
replaced:
export default function Privacy() {
    return (
        <p>Dieser Service benutzt Cookies um temporäre Seitenzustände zu speichern und eine Datenbank um Gruppen, ihre Mitglieder (nur Handynr, Vorname und optional Nachname oder abgekürzter Nachname), Gruppenaktivitäten und die Beteiligungen der Mitglieder zu speichern.
            Dies ist unumgänglich um die Funktionen auf dieser Seite bereitstellen zu können. Darüber hinaus findet kein Tracking und keine Weitergabe von Daten an Drittanbieter statt.
        </p>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/admin/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/admin/page.tsx
fileSize: 3336
replaced:
'use client'

import Link from "next/link";
import styles from './page.module.css'
import { useEffect, useState } from "react";
import { SessionContext } from "../_lib/SessionContext";
import Profile from "../_lib/Profile";
import useUser from "../_lib/useUser";
import Header from "../_lib/Header";
import { HandleDeletedUsersReq, HandleDeletedUsersResp } from "../_lib/api";
import { apiFetchPost } from "../_lib/user-management-client/apiRoutesClient";
import { LocalContext } from "../_lib/LocalContext";
import { userAndTokenFromStorages } from "../_lib/userAndToken";

export default function Page() {
    const user = useUser();
    const [comment, setComment] = useState('')
    const [spinning, setSpinning] = useState(false);

    function handleDeletedUsers() {
        const [user1, token1] = userAndTokenFromStorages();

        if (user1 == null || token1 == null) return;

        const req: HandleDeletedUsersReq = {
            user: user1,
            token: token1,
        }
        setSpinning(true);
        apiFetchPost<HandleDeletedUsersReq, HandleDeletedUsersResp>('/api/handle-deleted-users', req).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    break;
                case 'success':
                    setComment('Deleted users have been handled.');
                    break;
            }
        }).catch(reason => {
            console.error(reason);
            setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
        }).finally(() => {
            setSpinning(false);
        })
    }

    return (
        <>
            <Header user={user} line1={{text: 'pr-groups', fontSize: '1.2rem', bold: false}} margin='1rem' line2={{text: 'Administration', fontSize: '1.5rem', bold: true}} />
            <div className={styles.form}>
                <div className={styles.row}>
                    <Link className={styles.linkGroupCreate} href='/admin/group/create'>Create Group</Link>
                </div>
                <div className={styles.row}>
                    <Link className={styles.linkGroupDelete} href='/admin/group/delete'>Delete Group</Link>
                </div>
                <div className={styles.row}>
                    <Link className={styles.linkGroupChange} href='/admin/group/change'>Change Group</Link>
                </div>
                <div className={styles.row}>
                    <Link className={styles.linkGroupAdminList} href='/admin/group/admin/list'>List Group Admins</Link>
                </div>
                <div className={styles.row}>
                    <Link className={styles.linkGroupAdminAdd} href='/admin/group/admin/add'>Add Group Admin</Link>
                </div>
                <div className={styles.row}>
                    <Link className={styles.linkGroupAdminDelete} href='/group/admin/delete'>Delete Group Admin</Link>
                </div>
                <div className={styles.row}>
                    <a className={styles.linkHandleDeletedUsers} onClick={handleDeletedUsers}>Handle deleted users</a>
                </div>

                <p>{comment}</p>
            </div>
            {
                spinning &&
                <div className={'loader'}></div>
            }
       </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/admin/group/admin/add/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/admin/group/admin/add/page.tsx
fileSize: 2996
replaced:
'use client'

import Profile from "@/app/_lib/Profile";
import useUser from "@/app/_lib/useUser"
import styles from './page.module.css'
import { useState } from "react";
import { GroupAdminAddReq, GroupAdminAddResp } from "@/app/_lib/api";
import { SessionContext } from "@/app/_lib/SessionContext";
import { apiFetchPost } from "@/app/_lib/user-management-client/apiRoutesClient";
import Header from "@/app/_lib/Header";
import { userAndTokenFromStorages } from "@/app/_lib/userAndToken";

export default function Page() {
    const user = useUser();
    const [group, setGroup] = useState('')
    const [groupAdminUser, setGroupAdminUser] = useState('');
    const [comment, setComment] = useState('');

    async function onAddClick() {
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            setComment('Du bist nicht eingeloggt.')
            return;
        }
        const req: GroupAdminAddReq = {
            user: user1,
            token: token1,
            group: group,
            groupAdminUser: groupAdminUser
        }
        const resp = await apiFetchPost<GroupAdminAddReq, GroupAdminAddResp>('/api/group/admin/add', req)
        switch (resp.type) {
            case 'authFailed':
                setComment('Nicht authorisiert.');
                break;
            case 'success':
                setComment(`${groupAdminUser} ist jetzt ein Gruppen-Admin von ${group}.`)
                break;
            case 'wasGroupAdmin':
                setComment(`${groupAdminUser} war bereits vorher ein Gruppen-Admin von ${group}.`)
                break;
            case 'groupNotFound':
                setComment(`Gruppe ${group} nicht gefunden.`);
                break;
            case 'userNotFound':
                setComment(`User ${groupAdminUser} nicht gefunden.`);
                break;
            case 'error':
                setComment(`Unerwarteter Fehler: ${resp.error}`);
                break;
        }
    }

    return (
        <div>
            <Header user={user} line1={{ text: 'pr-groups / Admin', fontSize: '1.2rem', bold: false }} margin='1rem' line2={{ text: 'Gruppen-Admin hinzufügen', fontSize: '1.5rem', bold: true }} />
            <div className={styles.form}>
                <label className={styles.groupLabel} htmlFor='group'>Gruppe</label>
                <input className={styles.group} type='text' value={group} onChange={(e) => setGroup(e.target.value)} id='group' />
                <label className={styles.userLabel} htmlFor='user'>User</label>
                <input className={styles.user} type='text' value={groupAdminUser} onChange={(e) => setGroupAdminUser(e.target.value)} id='user' />
                <button className={styles.addButton} disabled={user == null} onClick={onAddClick}>Gruppen-Admin hinzufügen</button>
                <p className={styles.comment}>
                    {comment}
                </p>
            </div>
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/admin/group/create/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/admin/group/create/page.tsx
fileSize: 5102
replaced:
'use client';

import { useEffect, useState } from 'react';
import styles from './page.module.css'
import { apiFetchPost } from '@/app/_lib/user-management-client/apiRoutesClient';
import { GroupCreateReq, GroupCreateResp, ImgData } from '@/app/_lib/api';
import { SessionContext } from '@/app/_lib/SessionContext';
import { useRouter } from 'next/navigation';
import Profile from '@/app/_lib/Profile';
import useUser from '@/app/_lib/useUser';
import Header from '@/app/_lib/Header';
import Input from '@/app/_lib/Input';
import { LocalContext } from '@/app/_lib/LocalContext';
import { userAndTokenFromStorages } from '@/app/_lib/userAndToken';

export default function Page() {
    const [name, setName] = useState('');
    const [logoSrc, setLogoSrc] = useState('');
    const [logoAlt, setLogoAlt] = useState('');
    const [logoWidth, setLogoWidth] = useState('');
    const [logoHeight, setLogoHeight] = useState('');
    const [line1Text, setLine1Text] = useState('');
    const [line1FontSize, setLine1FontSize] = useState('');
    const [line1Bold, setLine1Bold] = useState(false);
    const [margin, setMargin] = useState('');
    const [line2Text, setline2Text] = useState('');
    const [line2FontSize, setline2FontSize] = useState('');
    const [line2Bold, setline2Bold] = useState(false);
    const [docTitle, setDocTitle] = useState('');
    const [comment, setComment] = useState('');
    const router = useRouter();
    const user = useUser();

    async function onCreateGroupClick() {
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            alert('Du bist nicht eingeloggt.');
            router.push('/login');
            return;
        }
        let logo: ImgData | null = null;
        try {
            if (logoSrc != '' && logoAlt != '') {
                const width = parseInt(logoWidth);
                const height = parseInt(logoHeight);

                if (width > 0 && height > 0) {
                    logo = {
                        src: logoSrc,
                        alt: logoAlt,
                        width: width,
                        height: height
                    }
                }
            }
        } catch (reason) {}
        const req: GroupCreateReq = {
            user: user1,
            token: token1,
            name: name,
            logo: logo,
            line1: {
                text: line1Text,
                fontSize: line1FontSize,
                bold: line1Bold
            },
            margin: margin,
            line2: {
                text: line2Text,
                fontSize: line2FontSize,
                bold: line2Bold
            },
            docTitle: docTitle
        }
        const resp = await apiFetchPost<GroupCreateReq, GroupCreateResp>('/api/group/create', req)
        switch (resp.type) {
            case 'authFailed':
                setComment('Nicht authorisiert!');
                break;
            case 'error':
                setComment('Unerwarteter Fehler: ' + resp.error);
                break;
            case 'success':
                setComment(`Gruppe ${name} erfolgreich erstellt.`);
                setName('');
                break;
            case 'duplicate':
                setComment(`Eine Gruppe mit dem Namen ${name} existiert bereits.`)
                break;
        }
    }
    return (
        <div>
            <Header user={user} line1={{ text: 'pr-groups | Administration', fontSize: '1.2rem', bold: false }} margin='1rem' line2={{ text: 'Neue Gruppe erstellen', fontSize: '1.5rem', bold: true }} />
            <div className={styles.form}>
                <Input label='Name' text={name} setText={setName} />
                <Input label='logo.src (optional)' text={logoSrc} setText={setLogoSrc} />
                <Input label='logo.alt (optional)' text={logoAlt} setText={setLogoAlt} />
                <Input label='logo.width (optional)' text={logoWidth} setText={setLogoWidth} />
                <Input label='logo.height (optional)' text={logoHeight} setText={setLogoHeight} />
                <Input label='line1.text' text={line1Text} setText={setLine1Text} />
                <Input label='line1.fontSize' text={line1FontSize} setText={setLine1FontSize} />
                <div><input type='checkbox' checked={line1Bold} onChange={() => setLine1Bold(!line1Bold)} /> Bold</div>
                <Input label='Margin zwischen line1 und line2' text={margin} setText={setMargin} />
                <Input label='line2.text' text={line2Text} setText={setline2Text} />
                <Input label='line2.fontSize' text={line2FontSize} setText={setline2FontSize} />
                <div><input type='checkbox' checked={line2Bold} onChange={() => setline2Bold(!line2Bold)} /> Bold</div>
                <Input label='Titel für Browser-Tab und App-Shortcut' text={docTitle} setText={setDocTitle} />
                <button className={styles.createGroup} onClick={onCreateGroupClick}>Gruppe erstellen</button>
                <p>{comment}</p>
            </div>
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/member/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/member/page.tsx
fileSize: 1016
replaced:
'use client'
import Link from 'next/link'
import styles from './page.module.css'
import Header from '../_lib/Header'
import useUser from '../_lib/useUser'
import Menu from '../_lib/Menu'
import { useState } from 'react'
export default function Page() {
    const user = useUser();
    const [cookiesAccepted, setCookiesAccepted] = useState(false);

    return (
        <>
            <Menu setCookiesAccepted={setCookiesAccepted}>
                <Header line1={{ text: 'pr-groups', fontSize: '1.5em', bold: true }} margin='0' line2={{ text: '', fontSize: '1em', bold: false }} user={user} />

                {cookiesAccepted &&
                    <div className={styles.links}>
                        <p>
                            <Link href='/admin'>Admin</Link>
                        </p>
                        <p>
                            <Link href='/group-admin'>Gruppen-Admin</Link>
                        </p>
                    </div>
                }
            </Menu>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/member/[group]/[phoneNr]/[token]/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/member/[group]/[phoneNr]/[token]/page.tsx
fileSize: 30953
replaced:
'use client';

import Link from 'next/link'
import styles from './page.module.css'
import { MouseEvent, PropsWithChildren, useCallback, useEffect, useRef, useState } from 'react';
import { useRouter } from 'next/navigation';
import { Acceptance, Activity, ActivityAcceptReq, ActivityAcceptResp, ImgData, Member, MemberDataReq, MemberDataResp, MemberDeleteMeReq, MemberDeleteMeResp, Participation } from '@/app/_lib/api';
import { formatDate, formatDateTime, formatTime, withStopPropagation } from '@/app/_lib/utils';
import { SessionContext } from '@/app/_lib/SessionContext';
import Profile from '@/app/_lib/Profile';
import { apiFetchPost } from '@/app/_lib/user-management-client/apiRoutesClient';
import Header from '@/app/_lib/Header';
import { HeaderLine } from '@/app/_lib/HeaderLine';
import FixedAbortController from '@/app/_lib/pr-client-utils/FixedAbortController';
import Image from 'next/image';
import ScrollableContainer from '@/app/_lib/pr-client-utils/ScrollableContainer';
import ModalDialog from '@/app/_lib/ModalDialog';
import Impressum from '@/app/_lib/pr-client-utils/Impressum';
import { Popup } from '@/app/Popup';
import Menu, { CustomMenuItem } from '@/app/_lib/Menu';
import { after } from 'node:test';
import WhatsAppLinkComp from '@/app/_lib/WhatsAppLinkComp';
import ActivityDetailsComp from '@/app/_lib/ActivityDetailsComp';
import Head from 'next/head';

const FAKE = true;

interface DateTimeProps {
    date: Date
    small: boolean;
    className?: string;
}
function DateTimeComp({ date, small, className }: DateTimeProps) {
    return (
        <>
            <div className={`${small ? styles.nextDateSmall : styles.nextDate} ${className ?? ''}`}>{formatDate(date)}</div>
            <div className={`${small ? styles.nextTimeSmall : styles.nextTime} ${className}`}>UM {formatTime(date)} UHR</div>
        </>
    )
}

interface NameProps {
    name: string;
    small: boolean;
}
function NameComp({ name, small }: NameProps) {
    return (
        <div className={small ? styles.nextDateSmall : styles.nextDate}>{name}</div>
    )
}

interface ActivityProps {
    dateHeader: string;
    user: string;
    activity: Activity;
    onAcceptClick: (accept: Acceptance) => void;
    // onDetailsClick: () => void;
}

function ActivityComp({ dateHeader, user, activity, onAcceptClick }: ActivityProps) {
    // activity.participations can contain objects with equal user, but different accept values. Then, the last array element is the latest decision of the specific user.
    // Now, filter the last decisions:
    const decisions: { [user: string]: Acceptance } = activity.participations.reduce<{ [user: string]: Acceptance }>((d, participation) => {
        d[participation.phoneNr] = participation.accept
        return d

        // return ({
        //     ...d,
        //     [participation.phoneNr]: participation.accept
        // })
    },
        {}
    )
    const [acceptNum, rejectNum] = Object.entries(decisions).reduce(
        ([acceptNum, rejectNum], entry) => [acceptNum + (entry[1] === 'accepted' ? 1 : 0), rejectNum + (entry[1] === 'rejected' ? 1 : 0)],
        [0, 0]
    )
    const date = activity.date != null ? new Date(activity.date) : null
    const freePlaces = (activity.capacity ?? 0) - acceptNum;
    // console.log('decisions', decisions);
    return (
        <>
            <div className={`${styles.labelNext} ${styles.indent}`}>{dateHeader}:</div>
            {date != null &&
                <div className={styles.indent}>
                    <DateTimeComp date={date} small={false} />
                </div>
            }
            <div className={`${styles.participants} ${styles.indent}`}>{`${acceptNum} TEILNEHMER`}</div>
            {activity.capacity != null && <div className={`${freePlaces >= 0 ? styles.free : styles.overbooked} ${styles.indent}`}>{freePlaces >= 0 ? `NOCH ${freePlaces} FREIE PLÄTZE!` : `${activity.capacity} Plätze überbucht!`}</div>}
            {/* <p>Erstellt: {formatDate(activity.creationDate)}</p> */}
            {/* <Link href={url}>
                    <p>{acceptNum} Zusagen</p>
                    <p>{rejectNum} Absagen</p>
                </Link> */}
            <div className={`${styles.activityButtons} ${styles.indent}`}>
                {
                    (decisions[user] == null || decisions[user] === 'undecided') &&
                    <>
                        <button className={styles.accept} onClick={(e) => { onAcceptClick('accepted'); e.stopPropagation() }}>MITMACHEN</button>
                        <button className={styles.reject} onClick={(e) => { onAcceptClick('rejected'); e.stopPropagation() }}>ABSAGEN</button>
                        <div className={styles.undecided}>Entscheide mich noch</div>
                    </>
                }
                {
                    decisions[user] === 'accepted' &&
                    <>
                        <div className={styles.accepted}>Ich komme!</div>
                        <button className={styles.reject} onClick={(e) => { onAcceptClick('rejected'); e.stopPropagation() }}>ABSAGEN</button>
                        <button className={styles.doubt} onClick={(e) => { onAcceptClick('undecided'); e.stopPropagation() }}>SPÄTER ENTSCHEIDEN</button>
                    </>
                }
                {
                    decisions[user] === 'rejected' &&
                    <>
                        <button className={styles.accept} onClick={(e) => { onAcceptClick('accepted'); e.stopPropagation() }}>ZUSAGEN</button>
                        <div className={styles.rejected}>Ich komme nicht.</div>
                        <button className={styles.doubt} onClick={(e) => { onAcceptClick('undecided'); e.stopPropagation() }}>SPÄTER ENTSCHEIDEN</button>
                    </>
                }
            </div>
        </>
    )
}

interface AdditionalHeaderProps {
    logo?: ImgData;
    line1: HeaderLine;
    margin: string;
    line2: HeaderLine;
}

interface WelcomeProps {
    prename: string;
}

function Welcome(p: WelcomeProps) {
    return (
        <div className={styles.welcome}>
            <div className={styles.hello}>HALLO,</div>
            <div className={styles.user}>
                {p.prename.toUpperCase()}!
            </div>
        </div>
    )
}

type Choice = 'undecided' | 'accepted' | 'rejected';

function formatName(member?: Member): string {
    if (member == null) return '';
    return member.prename + ' ' + member.surname;
}

function compareMemberName(a?: Member, b?: Member) {
    if (a == null || b == null) return 0;
    const na = formatName(a);
    const nb = formatName(b);
    if (na < nb) return -1;
    if (na > nb) return 1;
    return 0;
}

export default function Page({ params }: { params: { group: string; phoneNr: string; token: string } }) {
    const router = useRouter();
    const [group, setGroup] = useState('');
    const [phoneNr, setPhoneNr] = useState('');
    const [token, setToken] = useState('');
    const [activities, setActivities] = useState<Activity[]>([]);
    const [members, setMembers] = useState<Member[]>([]);
    const [comment, setComment] = useState('')
    const [prename, setPrename] = useState('');
    const [surname, setSurname] = useState('');
    const [additionalHeaderProps, setAdditionalHeaderProps] = useState<AdditionalHeaderProps | null>(null);
    const [firstOpen, setFirstOpen] = useState(0)
    const [activityIdx, setActivityIdx] = useState(0)
    const [spinning, setSpinning] = useState(true);
    const [detailsPopup, setDetailsPopup] = useState(false);
    const [docTitle, setDocTitle] = useState('pr-groups');
    const [afterDeleteSelf, setAfterDeleteSelf] = useState(false);
    const [cookiesAccepted, setCookiesAccepted] = useState(false);

    useEffect(() => {
        if (!cookiesAccepted) return;
        // console.log('effect ...');
        let decodedGroup: string;
        let decodedPhoneNr: string;
        let decodedToken: string;
        try {
            setGroup(decodedGroup = decodeURIComponent(params.group));
            setPhoneNr(decodedPhoneNr = decodeURIComponent(params.phoneNr));
            setToken(decodedToken = decodeURIComponent(params.token));
        } catch (reason) {
            setComment('Ungültiger Link!');
            return;
        }
        const req: MemberDataReq = {
            group: decodedGroup,
            phoneNr: decodedPhoneNr,
            token: decodedToken,
        }
        const ctx = new SessionContext();
        setSpinning(true);
        const abortController = new FixedAbortController();
        apiFetchPost<MemberDataReq, MemberDataResp>('/api/member', req, abortController.signal).then(resp => {
            // console.log('resp', resp);
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    setAfterDeleteSelf(true);
                    break;
                case 'success':
                    setAdditionalHeaderProps({
                        logo: resp.logo ?? undefined,
                        line1: resp.line1,
                        margin: resp.margin,
                        line2: resp.line2,
                    })
                    setPrename(resp.prename);
                    setSurname(resp.surname);
                    resp.activities.sort((a, b) => {
                        if (a.date != null && b.date != null) {
                            return a.date - b.date
                        }
                        if (a.date != null && b.date == null) return -1;
                        if (a.date == null && b.date != null) return 1;
                        return 0;
                    })
                    setActivities(resp.activities);
                    setMembers(resp.members);
                    setComment('');
                    ctx.group = decodedGroup
                    ctx.activities = resp.activities;
                    const now = Date.now();
                    const first = resp.activities.findIndex((a) => (a.date ?? 0) > now)
                    setFirstOpen(first);
                    setActivityIdx(first >= 0 ? first : 0);
                    setDocTitle(resp.docTitle ?? resp.line1.text);
                    break;
                case 'error':
                    if (FAKE) {
                        setAdditionalHeaderProps({
                            logo: {
                                src: '/logo-von-Homepage.png.webp',
                                alt: 'Logo',
                                width: 50,
                                height: 60,
                            },
                            line1: {
                                text: 'AFTER-WORK',
                                fontSize: '1.5rem',
                                bold: true
                            },
                            margin: '0.1rem',
                            line2: {
                                text: 'TENNIS',
                                fontSize: '1.2rem',
                                bold: false
                            }

                        })
                        setPrename('Peter');
                        setComment('');
                        ctx.group = 'TC Rot-Weiß Cham'
                        // const date = new Date('2024-05-22T18:00Z+02:00');
                        // const date = new Date('2024-05-22');
                        const date = new Date('2024-05-22T18:00+02:00');
                        // console.log('date', date);
                        const activity: Activity = {
                            name: '',
                            date: date.getTime(),
                            creationDate: Date.now(),
                            capacity: 8,
                            participations: []
                        }
                        setActivities([activity, {
                            ...activity,
                            date: date.getTime() + 7 * 24 * 3600 * 1000
                        }]);
                        setActivityIdx(1);
                    } else {
                        setComment('Unerwarteter Fehler: ' + resp.error)
                    }
                    break;
            }
        }).catch(reason => {
            if ('name' in reason && reason.name === 'AbortError') {
                // ignore
            } else {
                setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
            }
        }).finally(() => {
            setSpinning(false);
        })

        return () => {
            abortController.abort();
        }
    }, [params.group, params.phoneNr, params.token, cookiesAccepted])

    function onAcceptClick(i: number, accept: Acceptance) {
        // if (tokenRef.current == null) {
        //     setComment('Nicht eingeloggt.');
        //     return;
        // }
        // setComment('Sende Daten...');
        setSpinning(true);
        const req: ActivityAcceptReq = {
            phoneNr: phoneNr,
            token: token,
            group: group,
            activityCreationDate: activities[i].creationDate,
            accept: accept
        }
        apiFetchPost<ActivityAcceptReq, ActivityAcceptResp>('/api/group/activity/accept', req).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    break;
                case 'groupNotFound':
                    setComment('Gruppe nicht gefunden.');
                    break;
                case 'error':
                    setComment('Unerwarteter Fehler: ' + JSON.stringify(resp.error));
                    break;
                case 'success':
                    resp.activities.sort((a, b) => {
                        if (a.date != null && b.date != null) {
                            return a.date - b.date
                        }
                        if (a.date != null && b.date == null) return -1;
                        if (a.date == null && b.date != null) return 1;
                        return 0;
                    })
                    setActivities(resp.activities);
                    new SessionContext().activities = resp.activities;
                    setComment('');
                    break;
            }
        }).finally(() => {
            setSpinning(false);
        })
        // setActivities(d => d.map((activity, j) => j === i ? {
        //     ...activity,
        //     participations: [
        //         ...activity.participations,
        //         {
        //             user: user,
        //             date: new Date(),
        //             accept: accept
        //         }
        //     ]

        // } : activity))
    }

    const selActivity: Activity | null = activityIdx >= 0 && activityIdx < activities.length != null ? activities[activityIdx] : null

    const testRef = useRef<HTMLDivElement>(null)
    function onMeasure() {
        if (testRef.current == null) return;
        let element: HTMLElement | null = testRef.current;
        while (element != null) {
            const parent: Element | null = element.offsetParent;
            if (parent instanceof HTMLElement) {
                element = parent;
            } else {
                element = null;
            }
        }
    }

    const onBarElemClick = (i: number) => () => {
        setActivityIdx(i);
    }

    function onDetailsClick() {
        if (afterDeleteSelf) return;
        setDetailsPopup(true)
    }


    const onMenuClick = useCallback((i: number) => () => {
        if (afterDeleteSelf) return;
        switch (i) {
            case 0: {
                const req: MemberDataReq = {
                    group: group,
                    phoneNr: phoneNr,
                    token: token,
                }
                const ctx = new SessionContext();
                setSpinning(true);
                const abortController = new FixedAbortController();
                apiFetchPost<MemberDataReq, MemberDataResp>('/api/member', req, abortController.signal).then(resp => {
                    // console.log('resp', resp);
                    switch (resp.type) {
                        case 'authFailed':
                            setComment('Nicht authorisiert.');
                            break;
                        case 'success':
                            setAdditionalHeaderProps({
                                logo: resp.logo ?? undefined,
                                line1: resp.line1,
                                margin: resp.margin,
                                line2: resp.line2,
                            })
                            setPrename(resp.prename);
                            setSurname(resp.surname);

                            resp.activities.sort((a, b) => {
                                if (a.date != null && b.date != null) {
                                    return a.date - b.date
                                }
                                if (a.date != null && b.date == null) return -1;
                                if (a.date == null && b.date != null) return 1;
                                return 0;
                            })
                            setActivities(resp.activities);
                            setMembers(resp.members);
                            setComment('');
                            ctx.activities = resp.activities;
                            const now = Date.now();
                            const first = resp.activities.findIndex((a) => (a.date ?? 0) > now)
                            setActivityIdx(first >= 0 ? first : 0);
                            break;
                        case 'error':
                            if (FAKE) {
                                setAdditionalHeaderProps({
                                    logo: {
                                        src: '/logo-von-Homepage.png.webp',
                                        alt: 'Logo',
                                        width: 50,
                                        height: 60,
                                    },
                                    line1: {
                                        text: 'AFTER-WORK',
                                        fontSize: '1.5rem',
                                        bold: true
                                    },
                                    margin: '0.1rem',
                                    line2: {
                                        text: 'TENNIS',
                                        fontSize: '1.2rem',
                                        bold: false
                                    }

                                })
                                setPrename('Peter');
                                setComment('');
                                ctx.group = 'TC Rot-Weiß Cham'
                                // const date = new Date('2024-05-22T18:00Z+02:00');
                                // const date = new Date('2024-05-22');
                                const date = new Date('2024-05-22T18:00+02:00');
                                // console.log('date', date);
                                const activity: Activity = {
                                    name: '',
                                    date: date.getTime(),
                                    creationDate: Date.now(),
                                    capacity: 8,
                                    participations: []
                                }
                                setActivities([activity, {
                                    ...activity,
                                    date: date.getTime() + 7 * 24 * 3600 * 1000
                                }]);
                                setActivityIdx(1);
                            } else {
                                setComment('Unerwarteter Fehler: ' + resp.error)
                            }
                            break;
                    }
                }).catch(reason => {
                    if ('name' in reason && reason.name === 'AbortError') {
                        // ignore
                    } else {
                        setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
                    }
                }).finally(() => {
                    setSpinning(false);
                })
                break;

            }

            case 1:
                router.push('/');
                break;
        }
    }, [afterDeleteSelf, group, phoneNr, token, router])

    function onDeleteClick() {
        // Sicherheitsabfrage bereits im Impressum (/ Datenschutz)
        const ctx = new SessionContext();
        const phoneNr1 = phoneNr;
        const token1 = token;
        const req: MemberDeleteMeReq = {
            group: group,
            phoneNr: phoneNr,
            token: token
        }
        setSpinning(true);
        apiFetchPost<MemberDeleteMeReq, MemberDeleteMeResp>('/api/member/delete-me', req).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    break;
                case 'success':
                    setComment('Alle Daten entfernt. Dieser Link wird natürlich dann in Zukunft nicht mehr funktionieren. Bitte Seite schließen bzw. verlassen.');
                    setAfterDeleteSelf(true);
                    break;
                case 'error':
                    setComment('Unerwarteter Fehler: ' + resp.error);
                    break;
            }
        }).catch(reason => {
            setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
        }).finally(() => {
            setSpinning(false);
        })

    }

    let tmpPrename: string;
    let tmpSurname: string;

    const customMenuItems: CustomMenuItem[] = [
        {
            label: 'DATEN AKTUALISIEREN',
            onClick() {
                const req: MemberDataReq = {
                    group: group,
                    phoneNr: phoneNr,
                    token: token,
                }
                const ctx = new SessionContext();
                setSpinning(true);
                const abortController = new FixedAbortController();
                apiFetchPost<MemberDataReq, MemberDataResp>('/api/member', req, abortController.signal).then(resp => {
                    // console.log('resp', resp);
                    switch (resp.type) {
                        case 'authFailed':
                            setComment('Nicht authorisiert.');
                            break;
                        case 'success':
                            setAdditionalHeaderProps({
                                logo: resp.logo ?? undefined,
                                line1: resp.line1,
                                margin: resp.margin,
                                line2: resp.line2,
                            })
                            setPrename(resp.prename);
                            setSurname(resp.surname);

                            resp.activities.sort((a, b) => {
                                if (a.date != null && b.date != null) {
                                    return a.date - b.date
                                }
                                if (a.date != null && b.date == null) return -1;
                                if (a.date == null && b.date != null) return 1;
                                return 0;
                            })
                            setActivities(resp.activities);
                            setMembers(resp.members);
                            setComment('');
                            ctx.activities = resp.activities;
                            const now = Date.now();
                            const first = resp.activities.findIndex((a) => (a.date ?? 0) > now)
                            setActivityIdx(first >= 0 ? first : 0);
                            break;
                        case 'error':
                            if (FAKE) {
                                setAdditionalHeaderProps({
                                    logo: {
                                        src: '/logo-von-Homepage.png.webp',
                                        alt: 'Logo',
                                        width: 50,
                                        height: 60,
                                    },
                                    line1: {
                                        text: 'AFTER-WORK',
                                        fontSize: '1.5rem',
                                        bold: true
                                    },
                                    margin: '0.1rem',
                                    line2: {
                                        text: 'TENNIS',
                                        fontSize: '1.2rem',
                                        bold: false
                                    }

                                })
                                setPrename('Peter');
                                setComment('');
                                ctx.group = 'TC Rot-Weiß Cham'
                                // const date = new Date('2024-05-22T18:00Z+02:00');
                                // const date = new Date('2024-05-22');
                                const date = new Date('2024-05-22T18:00+02:00');
                                // console.log('date', date);
                                const activity: Activity = {
                                    name: '',
                                    date: date.getTime(),
                                    creationDate: Date.now(),
                                    capacity: 8,
                                    participations: []
                                }
                                setActivities([activity, {
                                    ...activity,
                                    date: date.getTime() + 7 * 24 * 3600 * 1000
                                }]);
                                setActivityIdx(1);
                            } else {
                                setComment('Unerwarteter Fehler: ' + resp.error)
                            }
                            break;
                    }
                }).catch(reason => {
                    if ('name' in reason && reason.name === 'AbortError') {
                        // ignore
                    } else {
                        setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
                    }
                }).finally(() => {
                    setSpinning(false);
                })

            }
        },
        {
            label: 'ZU ADMIN-SEITEN',
            onClick() {
                router.push('/');
            }
        }
    ]

    return (
        <>
            <title>{docTitle}</title>
            <div className={styles.page} onClick={withStopPropagation(onDetailsClick)}>

                {!afterDeleteSelf && <>
                    {additionalHeaderProps != null &&
                        <Header user={null} {...additionalHeaderProps} />
                    }
                    {
                        prename != '' &&
                        <Welcome prename={prename} />
                    }

                    {/* <div className={styles.adminLinks}>
                <Link className={styles.adminLink} href='/admin'>Admin</Link>
                <Link className={styles.adminLink} href='/group-admin'>Gruppen-Admin</Link>
            </div> */}
                    {/* <h1 className={styles.headerWelcome}>Hallo {name}!</h1> */}
                    {/* <h2 className={styles.headerGroup}>{group}</h2> */}
                    <Menu group={group} onDeleteMemberClick={onDeleteClick} customItems={customMenuItems}
                        setCookiesAccepted={setCookiesAccepted} />
                </>
                }
                <div className={styles.mainContainer}>
                    {/* <div className={styles.main}> */}
                    {comment != '' && <div className={`${styles.comment} ${styles.indent}`}>{comment}</div>}
                    {
                        !afterDeleteSelf && selActivity != null &&
                        <>
                            {/* <div className={styles.labelNext}>{selActivity.date == null ? selActivity.name : activityIdx === firstOpen ? 'NÄCHSTE VERANSTALTUNG' : activityIdx < firstOpen || firstOpen === -1 ? 'ALTE VERANSTALTUNG' : 'WEITERE VERANSTALTUNG'}:</div> */}
                            <ActivityComp dateHeader={selActivity.date == null ? selActivity.name : activityIdx === firstOpen ? 'NÄCHSTE VERANSTALTUNG' : activityIdx < firstOpen || firstOpen === -1 ? 'ALTE VERANSTALTUNG' : 'WEITERE VERANSTALTUNG'} activity={selActivity} user={phoneNr} onAcceptClick={(accept) => onAcceptClick(activityIdx, accept)} />
                            {/* <div ref={testRef} className={styles.testRow}><div className={styles.barElem}><DateTimeComp date={new Date()} small={true} /> */}

                        </>
                    }
                    {!afterDeleteSelf && selActivity == null &&
                        <>
                            <div className={`${styles.noActivities} ${styles.indent}`}>Noch keine Aktivitäten in dieser Gruppe</div>
                        </>
                    }
                    {/* </div> */}
                    {!afterDeleteSelf && <>
                        <ScrollableContainer className={styles.activityBar} snapOffset={80 - 18 /* test */ + 10} snapWidth={160} snap={activityIdx} setSnap={setActivityIdx} >
                            {
                                activities.map((a, i) => <div key={i}><div onClick={withStopPropagation(onBarElemClick(i))} className={styles.barElem + (i < firstOpen ? ' ' + styles.barElemOld : '') + (i === activityIdx ? ' ' + styles.barElemActive : '')}>
                                    {a.date != null ? <DateTimeComp date={new Date(a.date)} small={true} /> : <NameComp name={a.name} small={true} />}
                                </div></div>)
                            }
                        </ScrollableContainer>

                    </>
                    }
                </div>
                {
                    !afterDeleteSelf &&
                    <Popup visible={detailsPopup && selActivity != null} setVisible={setDetailsPopup}>
                        <ActivityDetailsComp group={group} selActivity={selActivity} members={members}  />
                    </Popup>
                }
                {
                    spinning &&
                    <div className={'loader'}></div>
                }
            </div>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/member/[group]/[phoneNr]/[token]/layout.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/member/[group]/[phoneNr]/[token]/layout.tsx
fileSize: 846
replaced:

export default function Layout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {


  {/*
      <div className='d5'>
             <div className='d6'>
             </div>
             <div id='d4' className='d4'>
               d4
             </div>
           </div>
           <div className='d2'>
           </div>
           <div className='d3'>
             {children}
           </div>
  */}

  return (
    <>
      <div className='memberOuter'>
        <div className='memberInner'>
          <div className='d5'>
            <div className='d6'>
            </div>
            <div id='d4' className='d4'>
            </div>
          </div>
          <div className='d2'>
          </div>
          {children}
        </div>
      </div>
      {/* <div className='d3'>
        {children}
      </div> */}

    </>
  );
}



path: "/home/peter/my_projects/individual-gits/pr-groups/app/member/[group]/[phoneNr]/[token]/activity-details/[activityIdx]/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/member/[group]/[phoneNr]/[token]/activity-details/[activityIdx]/page.tsx
fileSize: 2703
replaced:
'use client'

import Profile from "@/app/_lib/Profile";
import { SessionContext } from "@/app/_lib/SessionContext";
import { Activity, ActivityDetailsReq, ActivityDetailsResp, Participation } from "@/app/_lib/api";
import useUser from "@/app/_lib/useUser";
import { apiFetchPost } from "@/app/_lib/user-management-client/apiRoutesClient";
import { formatDateTime } from "@/app/_lib/utils";
import { useEffect, useState } from "react";
import styles from './page.module.css'
import { userAndTokenFromStorages } from "@/app/_lib/userAndToken";

export default function Page({ params }: { params: { activityIdx: string } }) {
    const user = useUser();
    const [group, setGroup] = useState('');
    const [activity, setActivity] = useState<Activity | null>(null);
    const [comment, setComment] = useState('');

    useEffect(() => {
        const ctx = new SessionContext();
        const group1 = ctx.group;
        setGroup(group1 ?? '');
        const [user1, token1] = userAndTokenFromStorages();

        if (user1 == null || token1 == null || group1 == null) return;
        const activities = ctx.activities;
        if (activities == null) return;
        const activityIdx = parseInt(params.activityIdx);
        setActivity(activities[activityIdx] ?? null)

    }, [params.activityIdx])

    const decisions: { [user: string]: Participation } | undefined = activity?.participations.reduce((d, participation) => ({
        ...d,
        [participation.phoneNr]: participation
    }),
        {}
    )

    const accept: Participation[] = decisions == null ? [] : Object.values(decisions).filter((p => p.accept === 'accepted'))
    const reject: Participation[] = decisions == null ? [] : Object.values(decisions).filter((p => p.accept === 'rejected'))

    return (
        <div>
            <Profile user={user} />
            <h1 className={styles.headerGroup}>{group}</h1>
            <h2 className={styles.headerActivity}>{activity?.name}</h2>
            <h3 className={styles.headerAccepts}>Zusagen</h3>
            <div>
                {accept.length === 0 ? <span className={styles.none}>keine</span> :
                accept.map((participation, i) => <div key={i}>{participation.phoneNr} <span className={styles.date}>{formatDateTime(new Date(participation.date))}</span></div>)}
            </div>
            <h3 className={styles.headerRejects}>Absagen</h3>
            <div>
                {reject.length === 0 ? <span className={styles.none}>keine</span> :
                reject.map((participation, i) => <div key={i}>{participation.phoneNr} <span className={styles.date}>{formatDateTime(new Date(participation.date))}</span></div>)}
            </div>
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/page.tsx
fileSize: 4779
replaced:
'use client'

import Image from "next/image";
import styles from "./page.module.css";
import Link from "next/link";
import Profile from "./_lib/Profile";
import { StrictMode, useEffect, useRef, useState } from "react";
import { SessionContext } from "./_lib/SessionContext";
import useUser from "./_lib/useUser";
import Header from "./_lib/Header";
import Menu from "./_lib/Menu";
import { useRouter } from "next/navigation";
import Input2 from "./_lib/pr-client-utils/Input2";
import FormComp from "./_lib/pr-client-utils/FormComp";
import Button from "./_lib/Button";

export default function Home() {
  // const user = useUser();
  const router = useRouter()
  const [pageWidth, setPageWidth] = useState(100);
  const mainDivRef = useRef<HTMLDivElement>(null);
  const [registering, setRegistering] = useState(false);
  const [user, setUser] = useState('');
  const [passwd, setPasswd] = useState('');
  const [passwdRepeat, setPasswdRepeat] = useState('');
  const [cookiesAccepted, setCookiesAccepted] = useState(false);

  function onLoginClick() {
    router.push('/login');
  }

  function onRegisterClick() {
    // setRegistering(true)
    router.push('/register')
  }

  useEffect(() => {
    const mainDiv = mainDivRef.current;
    if (mainDiv == null) {
      console.error('mainDivRef.current null');
      return;
    }
    const w = window.innerWidth > 0 ? window.innerWidth : screen.width;
    setPageWidth(w);
    const resizeObserver = new ResizeObserver((entries, observer) => {
      const w = window.innerWidth > 0 ? window.innerWidth : screen.width;
      setPageWidth(w);
    })

    resizeObserver.observe(mainDiv);

    return () => {
      resizeObserver.unobserve(mainDiv)
    }

  }, [])

  const descMembers = 'Ermögliche den Mitgliedern deiner Gruppe eine einfache Anmeldung zu Aktivitäten oder Ausflügen.'
  const descAllActivities = 'Behalte einen guten Überblick über die Aktivitäten der Gruppen, die du betreust, in deinem Desktop-Browser.'

  return (
    <StrictMode>
      <Menu setCookiesAccepted={setCookiesAccepted} />
      <div className={styles.container}>
        <div className={styles.header}>
          <h1>pr-groups</h1>
          <div className={styles.buttons}>
            <Button className={styles.register} onClick={onRegisterClick}>Konto erstellen</Button>
            <Button className={styles.login} onClick={onLoginClick}>Anmelden</Button>
          </div>
        </div>
        <div ref={mainDivRef} className={styles.main}>
          {
            registering &&
            <FormComp >
              <h1>Konto erstellen</h1>
              <Input2 label='User' type='text' text={user} setText={setUser} />
              <Input2 type='password' label='Passwort' text={passwd} setText={setPasswd} />
              <Input2 type='password' label='Passwort wiederholen' text={passwdRepeat} setText={setPasswdRepeat} />
              <button className={styles.registerButton} onClick={onRegisterClick}>Weiter</button>
            </FormComp>

          }
          <div className={styles.row}>
            <h2>Gruppenaktivitäten super-easy organisiert!</h2>
          </div>
          <div className={styles.row}>
            <Image src='/group-friends-jumping-top-hill.jpg' alt='Gruppe' width={576} height={384} className={styles.coverImg} />
            <Image src='/43702940_9078334.jpg' alt='Friends' width={600} height={400} className={styles.coverImg} />
            {
              pageWidth < 800 && <p>{descMembers}</p>
            }
            <div className={styles.box}>
              <div className={styles.border}>
                <div className={styles.largeImg}>
                  {/* <Image src='/screenshot-member.png' alt='Screenshot Mitgliederansicht' width={380} height={670} /> */}
                  <Image src='/screenshot-member.png' alt='Screenshot Mitgliederansicht' width={190} height={335} />
                </div>
              </div>
              {pageWidth >= 800 && <p>{descMembers}</p>}
            </div>
            {
              pageWidth < 800 && <p>{descAllActivities}</p>
            }
            <div className={styles.box}>
              <div className={styles.border}>
                <div className={styles.largeImg}>
                  {/* <Image className={styles.screenShot} src='/screenshot-all-activities.png' alt='Screenshot all-activities' width={1865} height={893} /> */}
                  <Image className={styles.screenShot} src='/screenshot-all-activities.png' alt='Screenshot all-activities' width={932} height={446} />
                  {pageWidth >= 800 && <p className={styles.descAllActivities}>{descAllActivities}</p>}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </StrictMode>
  );
}


path: "/home/peter/my_projects/individual-gits/pr-groups/app/tennis/ideen/hobby-liga/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/tennis/ideen/hobby-liga/page.tsx
fileSize: 2732
replaced:
import styles from './page.module.css'
export default function Page() {
    return (
        <article className={styles.article}>
            <h1>Idee für Hobby-Liga-System jenseits LK und Co</h1>
            <section>
                <h2>Ausgangssituation</h2>
                eine Gruppe von Tennisspielern mit ziemlich heterogenem Leistungsniveau (für Insider: ähnlich der Chamer After-Work-Gruppe), die sich regelmäßig zu gemeinsamen Doppelspielen treffen
            </section>
            <section>
                <h2>Ziel</h2>
                Abwechslungsreiche Matches für so viel Spielfreude wie möglich
            </section>
            <section>
                <h2>Paarbildung</h2>
                Zunächst gibt es für jeden der Spieler einen Zettel mit seinem Namen drauf in einem großen (virtuellen) Topf.
                Aus dem Topf wird ein Spieler gezogen. Dieser darf seinen Doppelpartner frei wählen.
                Dann wird der nächste Spieler gezogen, welcher wiederum aus den verbleibenden Spielern wählen darf usw. bis alle Paare gebildet wurden.
                Dann wird für jeden Spieler, der dieses Mal nicht wählen durfte, ein zusätzlicher Zettel mit seinem Namen darauf in den (virtuellen) Topf gelegt,
                damit seine Chancen für die nächste Ziehung steigen.
            </section>
            <section>
                <h2>Die Liga</h2>
                In jedem Match gibt es für jeden gewonnenen Satz für jeden der Spieler im Siegerpaar einen Pluspunkt und für jeden Spieler im Verliererpaar einen
                Minuspunkt. Die Punkte werden dann wie üblich notiert, z.B.:
                <pre>
                    Spieler 1    18:2<br/>
                    Spieler 2    16:4<br/>
                    ...
                </pre>
            </section>
            <section>
                <h2>Auswahl der Paare, die gegeneinander spielen</h2>
                In jedem Paar (siehe oben im Abschnitt &quot;Paarbildung&quot;) werden die Ligapunkte der beiden Spieler miteinander addiert. Das Paar mit der besten Differenz spielt gegen das mit der zweitbesten, das mit der drittbesten gegen das mit der viertbesten, usw.
            </section>
            <section>
                <h2>Variante</h2>
                Ab und zu kann zur Abwechslung auf eine Auslosung der Paare verzichtet werden und stattdessen stur nach Rangfolge gespielt werden, d.h. folgende Matches:
                <ol>
                    <li>Match: Spieler 1, Spieler 2 gegen Spieler 3, Spieler 4</li>
                    <li>Match: Spieler 5, Spieler 6 gegen Spieler 7, Spieler 8</li>
                    <li>...</li>
                </ol>
            </section>
        </article>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/ModalDialog.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/ModalDialog.tsx
fileSize: 705
replaced:
'use client'

import { PropsWithChildren } from "react";

import styles from './ModalDialog.module.css'
import FocusTrap from "focus-trap-react";

export interface ModalDialogProps {
    header?: string
    onDeactivate?: () => void
}

export default function ModalDialog({ header, onDeactivate, children }: PropsWithChildren<ModalDialogProps>) {
    return (
        <FocusTrap active={true} focusTrapOptions={{
            onDeactivate: onDeactivate
        }}>
            <div className={styles.outer}>
                <div className={styles.inner}>
                    {header && <h1>{header}</h1>}
                    {children}
                </div>
            </div>
        </FocusTrap>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/Menu.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/Menu.tsx
fileSize: 9750
replaced:
import { PropsWithChildren, useEffect, useState } from "react";
import styles from './Menu.module.css'
import Image from "next/image";
import { Popup } from "../Popup";
import Impressum from "./pr-client-utils/Impressum";
import { SessionContext } from "./SessionContext";
import { apiFetchPost } from "./user-management-client/apiRoutesClient";
import { DeleteReq, DeleteResp } from "./user-management-server/user-management-common/delete";
import { withStopPropagation } from "./utils";
import ImgAttributions from "./ImgAttributions";
import { myImgAttributions } from "../myImgAttributions";
import { LocalContext } from "./LocalContext";
import { userAndTokenFromStorages } from "./userAndToken";
import CookieDlg from "./pr-client-utils/CookieDlg";
import Label from "./Label";
import Checkbox from "./Checkbox";

export type CustomMenuItem = {
    type?: 'normal'
    label: string | { label: string; src: string; alt: string; width: number; height: number };
    onClick: () => void;
} | {
    type: 'checkbox';
    label: string;
    checked: boolean;
    setChecked: (checked: boolean) => void;
}

export interface MenuProps {
    group?: string | null;
    onDeleteMemberClick?: (() => void) | null;
    customItems?: CustomMenuItem[];
    customSpinning?: boolean;
    setCookiesAccepted: (accepted: boolean) => void;
}

export default function Menu({ group, onDeleteMemberClick, customItems, customSpinning, setCookiesAccepted, children }: PropsWithChildren<MenuProps>) {
    const [impressum, setImpressum] = useState(false);
    const [about, setAbout] = useState(false);
    // const [cookiePopup, setCookiePopup] = useState(false);
    const [imgAttr, setImgAttr] = useState(false);
    const [menu, setMenu] = useState(false);
    const [spinning, setSpinning] = useState(false);
    const [selfDeleted, setSelfDeleted] = useState(false);

    // useEffect(() => {
    //     const ctx = new SessionContext();
    //     const cookiesShown = ctx.cookiesShown;
    //     if (!cookiesShown) {
    //         setCookiePopup(true);
    //         ctx.cookiesShown = true;
    //     }
    // }, [])

    function onMenuClick() {
        setMenu(visible => !visible);
    }

    function deleteProfile() {
        setSpinning(true);
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            return;
        }
        const req: DeleteReq = {
            user: user1,
            token: token1
        }
        setSpinning(true);
        apiFetchPost<DeleteReq, DeleteResp>('/api/user/delete', req).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    console.warn('authFailed');
                    break;
                case 'success':
                    setSelfDeleted(true);
                    break;
                case 'error':
                    console.error('Unerwarteter Fehler: ', resp.error)
                    break;
            }
        }).catch(reason => {
            console.error('Unerwarteter Fehler:', reason, JSON.stringify(reason));
        }).finally(() => {
            setSpinning(false);
        })
    }

    return (
        <>
            {
                selfDeleted ? <p>Your profile was deleted. Please leave this site.</p> :
                    <>
                        {children}

                        <div tabIndex={0} className={styles.menuButton} onClick={withStopPropagation(() => { onMenuClick() })} onKeyUp={(e) => {
                            if (e.key === 'Enter' || e.key === ' ') onMenuClick();
                        }} >
                            <Image className={styles.menuImg} src='/main-menu.svg' width={32 * 0.65} height={32 * 0.65} alt='Menu' />
                        </div>
                        <Popup visible={menu} setVisible={setMenu}>
                            <div className={styles.menu}>
                                {customItems != null &&
                                    customItems.map((item, i) =>
                                        item.type === 'checkbox' ?
                                            <Checkbox key={i} label={item.label} checked={item.checked} setChecked={item.setChecked} />
                                            :
                                            <button key={i} onClick={withStopPropagation(() => {
                                                setMenu(false);
                                                item.onClick();
                                            })}>
                                                {typeof item.label === 'string' ? item.label :
                                                    <div className={styles.labelAndImg}>{item.label.label} <Image src={item.label.src} alt={item.label.alt} width={item.label.width} height={item.label.height} /></div>}
                                            </button>
                                    )
                                }
                                <button onClick={withStopPropagation(() => { setImpressum(true); setMenu(false) })}>IMPRESSUM / DATENSCHUTZ</button>
                                <button onClick={withStopPropagation(() => { setAbout(true); setMenu(false) })}>ABOUT</button>
                                <button onClick={withStopPropagation(() => { setImgAttr(true); setMenu(false) })}>BILDER VON FREEP!K</button>
                            </div>
                            {/* <div className={styles.popupButtonRow}>
                                <button onClick={withStopPropagation(() => setMenu(false))}>SCHLIEẞEN</button>
                            </div> */}
                        </Popup>
                        <CookieDlg setCookiesAccepted={setCookiesAccepted} />
                        {/* {
                            cookiePopup &&
                            <CookieDlg onOk={() => setCookiePopup(false)}  />
                        } */}
                        {/* <Popup visible={cookiePopup} setVisible={setCookiePopup}>
                            Dieser Service benutzt Cookies um temporäre Seitenzustände zu speichern und eine Datenbank um Gruppen, ihre Mitglieder (nur Handynr, Vorname und optional Nachname oder abgekürzter Nachname), Gruppenaktivitäten und die Beteiligungen der Mitglieder zu speichern.
                            Sie dürfen diese Seite nur weiter benutzen, wenn Sie dies akzeptieren. Andernfalls verlassen Sie bitte diese Seite.
                            <div className={styles.popupButtonRow}>
                                <button onClick={withStopPropagation(() => { setCookiePopup(false); })}>OK</button>
                            </div>
                        </Popup> */}
                        <Popup visible={impressum} setVisible={setImpressum}>
                            <div className={styles.impressum}>
                                <Impressum group={group ?? null} name='Peter Reitinger' street='Birkenweg' houseNr='8' postalCode='93482' city='Pemfling' phone='09971-6131' mail='peter.reitinger(at)gmail.com' onDeleteClick={group == null ? deleteProfile : (onDeleteMemberClick ?? null)} />
                            </div>
                            {/* <div className={styles.popupButtonRow}>
                                <button onClick={withStopPropagation(() => setImpressum(false))}>SCHLIEẞEN</button>
                            </div> */}
                        </Popup>
                        <Popup visible={about} setVisible={setAbout}>
                            <h1>About pr-groups</h1>
                            <Label>Layout & Design der Abstimmungsseite:</Label>
                            <p>ALEXANDER POHL</p>
                            <Label>Layout & Design der Admin-Seiten und Programmierung:</Label>
                            <Image className={styles.picture} src='/Peter-Reitinger.jpg' width={200} height={199} alt='Peter Reitinger' />
                            <p>PETER REITINGER </p>
                            {/* <table className={styles.aboutTable}>
                                <tbody>
                                    <tr>
                                        <td colSpan={2}>Layout & Design der Abstimmungsseite:</td>
                                    </tr>
                                    <tr>
                                        <td>ALEXANDER POHL</td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td colSpan={2}>Layout & Design der Admin-Seiten und Programmierung:</td>
                                    </tr>
                                    <tr>
                                        <td>PETER REITINGER</td>
                                        <td><Image className={styles.picture} src='/Peter-Reitinger.jpg' width={200} height={199} alt='Peter Reitinger' /></td>
                                    </tr>
                                </tbody>
                            </table> */}
                            {/* <div className={styles.popupButtonRow}>
                                <button onClick={withStopPropagation(() => setAbout(false))}>SCHLIEẞEN</button>
                            </div> */}
                        </Popup>
                        <Popup visible={imgAttr} setVisible={setImgAttr}>
                            <ImgAttributions attributions={myImgAttributions} />
                        </Popup >
                        {
                            (spinning || customSpinning) &&
                            <div className='loader'></div>
                        }
                    </>
            }
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/Input.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/Input.tsx
fileSize: 802
replaced:
import { forwardRef, useId } from 'react';
import styles from './Input.module.css'

export interface InputProps {
    label: string;
    text: string;
    setText: (text: string) => void;
    onEnter?: () => void;
}
const Input = forwardRef<HTMLInputElement, InputProps>(function Input({ label, text, setText, onEnter }: InputProps, ref) {
    const id = useId()
    return (
        <>
            <label htmlFor={id} className={styles.label}>{label}</label>
            <input ref={ref} id={id} type='text' value={text} onChange={(e) => setText(e.target.value)} className={styles.input}
                onKeyUp={onEnter && ((e) => {
                    if (e.key === 'Enter') {
                        onEnter();
                    }
                })} />
        </>
    )
})
export default Input;

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/EscapableFlexComp.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/EscapableFlexComp.tsx
fileSize: 448
replaced:
import { PropsWithChildren } from 'react';
import EscapableComp from './EscapableComp';
import styles from './EscapableFlexComp.module.css'

export interface EscapableFlexProps {
    onCancel: () => void;
}
export default function EscapableFlexComp(props: PropsWithChildren<EscapableFlexProps>) {
    return (
        <EscapableComp className={styles.content} onCancel={props.onCancel}>
            {props.children}
        </EscapableComp>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/Checkbox.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/Checkbox.tsx
fileSize: 634
replaced:
import { FocusEventHandler } from "react";
import styles from './Checkbox.module.css'

interface CheckboxProps {
    label?: string;
    checked: boolean;
    setChecked: (v: boolean) => void;
    onBlur?: FocusEventHandler<HTMLInputElement>;
    className?: string;
}
export default function Checkbox({ label, checked: value, setChecked: setValue, onBlur, className }: CheckboxProps) {
    return (
        <div>
            <label className={styles.checkbox + (className ? ' ' + className :   '')}><input type='checkbox' checked={value} onChange={() => { setValue(!value) }} onBlur={onBlur} />{label}</label>
        </div>
    )
}


path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/ImgAttributions.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/ImgAttributions.tsx
fileSize: 1084
replaced:
import Image from "next/image"
import { PropsWithChildren } from "react"
import styles from './ImgAttributions.module.css'

function ImgAndAttrRow({ url, children }: PropsWithChildren<{ url: string }>) {
    return (
        <tr>
            <td><Image src={url} alt={url} width={32} height={32} /></td>
            <td>{children}</td>
        </tr>
    )
}

export interface ImgAttribution {
    imgUrl: string;
    attribution: React.ReactNode;
}

export default function ImgAttributions({ attributions }: { attributions: ImgAttribution[] }) {
    return (
        <>
            <h3>Vielen Dank für folgende kostenlose Bilder bereit gestellt unter freepik.com:</h3>
            <div className={styles.center}>
                <table className={styles.imgTable}>
                    <tbody>
                        {
                            attributions.map(({imgUrl, attribution}) => (<ImgAndAttrRow key={imgUrl} url={imgUrl}>{attribution}</ImgAndAttrRow>))
                        }
                    </tbody>
                </table>
            </div>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/WhatsAppLinkComp.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/WhatsAppLinkComp.tsx
fileSize: 379
replaced:
import Image from "next/image";
import { whatsappLink } from "./whatsapp";

export interface WhatsAppLinkProps {
    phoneNr: string;
}
export default function WhatsAppLinkComp({phoneNr}: WhatsAppLinkProps) {
    return (
        <a href={whatsappLink(phoneNr, '')} target="blank"><Image src='/WhatsApp/Print_Stacked_Green.png' alt='WhatsApp' width={50} height={32}/></a>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/MemberAdd.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/MemberAdd.tsx
fileSize: 2044
replaced:
import { group } from 'console'
import Input from './Input'
import styles from './MemberAdd.module.css'
import { useState } from 'react';
import { SessionContext } from './SessionContext';
import { GroupMemberAddReq, GroupMemberAddResp, Member } from './api';
import { apiFetchPost } from './user-management-client/apiRoutesClient';

export interface MemberAddProps {
    initialGroup: string;
    onAdd: (memberData: {group: string; newPhoneNr: string; prename: string; surname: string}) => void;
    onCancel: () => void
}

export default function MemberAdd({ initialGroup, onAdd, onCancel }: MemberAddProps) {
    const [group, setGroup] = useState(initialGroup)
    const [newPhoneNr, setNewPhoneNr] = useState('');
    const [prename, setPrename] = useState('');
    const [surname, setSurname] = useState('');
    const [comment, setComment] = useState('');

    async function onAddClick() {
        if (group == '') {
            setComment('Gruppe darf nicht leer sein!');
            return;
        }
        if (newPhoneNr == '') {
            setComment('Telefonnr darf nicht leer sein!');
            return;
        }
        if (prename == '' && surname == '') {
            setComment('Vorname und Nachname dürfen nicht beide leer sein!');
            return;
        }
        onAdd({group, newPhoneNr, prename, surname})
    }

    return <>
        <Input label='Gruppe' text={group} setText={setGroup} />
        <Input label='Telefonnr. des neuen Gruppenmitglieds (für WhatsApp-Funktionen)' text={newPhoneNr} setText={setNewPhoneNr} />
        <Input label='Vorname des neuen Mitglieds' text={prename} setText={setPrename} />
        <Input label='Nachname (ggf. Kürzel) des neuen Mitglieds' text={surname} setText={setSurname} />
        <div className={styles.buttons}>
            <button className={styles.addButton} onClick={onAddClick}>GRUPPENMITGLIED HINZUFÜGEN</button>
            <button className={styles.cancelButton} onClick={onCancel}>ABBRECHEN</button>
        </div>
        <p>{comment}</p>
    </>
}


path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/Label.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/Label.tsx
fileSize: 213
replaced:
import { PropsWithChildren } from "react";
import styles from './Label.module.css'

export default function Label({ children }: PropsWithChildren<{}>) {
    return <div className={styles.label}>{children}</div>
}


path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/ActivityDetailsComp.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/ActivityDetailsComp.tsx
fileSize: 5883
replaced:
'use client'
import { useCallback, useEffect, useState } from 'react';
import styles from './ActivityDetailsComp.module.css'
import { Activity, Member, Participation } from './api'
import Checkbox from './Checkbox';
import { formatDateTime } from './utils';
import WhatsAppLinkComp from './WhatsAppLinkComp';
import { LocalContext } from './LocalContext';

export interface ActivityDetailsProps {
    group: string;
    selActivity: Activity | null;
    members: Member[];
}
export default function ActivityDetailsComp({ group, selActivity, members }: ActivityDetailsProps) {
    const [simpleLists, setSimpleLists] = useState(false);

    useEffect(() => {
        const ctx = new LocalContext();
        setSimpleLists(ctx.simpleActivityDetails)
    }, [])

    const setSimpleListsAlsoInLocalStorage = useCallback((b: boolean) => {
        const ctx = new LocalContext();
        setSimpleLists(ctx.simpleActivityDetails = b);
    }, [])

    const decisions: { [user: string]: Participation } | undefined = selActivity?.participations.reduce((d, participation) => ({
        ...d,
        [participation.phoneNr]: participation
    }),
        {}
    )

    const accept: Participation[] = decisions == null ? [] : Object.values(decisions).filter((p => p.accept === 'accepted'))
    const reject: Participation[] = decisions == null ? [] : Object.values(decisions).filter((p => p.accept === 'rejected'))
    const undecided: string[] = decisions == null ? [] : (members.map(member => member.phoneNr).filter(phoneNr => !accept.map(p => p.phoneNr).includes(phoneNr) && !reject.map(p => p.phoneNr).includes(phoneNr)))

    function phoneNrToName(phoneNr: string): string {
        if (selActivity == null) return '';
        const member = members.find(member => member.phoneNr === phoneNr)
        if (member == null) return '';
        return member.prename + ' ' + member.surname;
    }
    return <>
        <Checkbox label='Details nicht anzeigen' checked={simpleLists} setChecked={setSimpleListsAlsoInLocalStorage} className={styles.detailsCheckbox} />
        <h1 className={styles.headerGroup}>{group}</h1>
        <h2 className={styles.headerActivity}>{selActivity?.name} {selActivity?.date != null && formatDateTime(selActivity?.date, true)}</h2>
        <div className={styles.detailLists}>
            <h3 className={styles.headerAccepts}>{accept.length === 1 ? '1 Zusage' : `${accept.length} Zusagen`}</h3>
            <div>
                {
                    accept.length === 0 ? <span className={styles.none}>keine</span> :
                        (simpleLists ?
                            accept.map((participation, i) => (
                                <div key={participation.phoneNr}>
                                    {phoneNrToName(participation.phoneNr)}
                                </div>
                            ))
                            : <table>
                                <tbody>

                                    {
                                        accept.map((participation, i) => (
                                            <tr key={i}>
                                                <td className={styles.detailName}>{phoneNrToName(participation.phoneNr)}</td>
                                                <td><WhatsAppLinkComp phoneNr={participation.phoneNr} /></td>
                                                <td className={styles.detailDate}>{formatDateTime(new Date(participation.date))}</td>
                                            </tr>))
                                    }

                                </tbody>
                            </table>
                        )
                }
            </div>
            <h3 className={styles.headerRejects}>{reject.length === 1 ? '1 Absage' : `${reject.length} Absagen`}</h3>
            <div>
                {
                    reject.length > 0 &&
                    (simpleLists ?
                        reject.map((participation) => (
                            <div key={participation.phoneNr}>
                                {phoneNrToName(participation.phoneNr)}
                            </div>
                        ))
                        :
                        <table>
                            <tbody>

                                {
                                    reject.map((participation, i) => (
                                        <tr key={i}>
                                            <td className={styles.detailName}>{phoneNrToName(participation.phoneNr)}</td>
                                            <td><WhatsAppLinkComp phoneNr={participation.phoneNr} /></td>
                                            <td className={styles.detailDate}>{formatDateTime(new Date(participation.date))}</td>
                                        </tr>))
                                }

                            </tbody>
                        </table>
                    )
                }

            </div>
            <h3 className={styles.headerUndecided}>{`${undecided.length === 1 ? 'Eine Person hat noch nicht abgestimmt oder kann es noch nicht sagen:' : `${undecided.length} haben noch nicht abgestimmt oder können es noch nicht sagen`}`}</h3>

            {undecided.length > 0 && (simpleLists ?
                undecided.map(phoneNr => <div key={phoneNr}>{phoneNrToName(phoneNr)}</div>) :
                <table>
                    <tbody>
                        {
                            undecided.map((phoneNr, i) => <tr key={i}>
                                <td className={styles.detailName}>{phoneNrToName(phoneNr)}</td>
                                <td><WhatsAppLinkComp phoneNr={phoneNr} /></td>
                            </tr>)
                        }
                    </tbody>
                </table>)
            }        </div>
    </>

}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/Button.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/Button.tsx
fileSize: 426
replaced:
import { PropsWithChildren } from "react";
import styles from './Button.module.css'

export interface ButtonProps {
    className: string;
    onClick: () => void
}

export default function Button({children, className, onClick}: PropsWithChildren<ButtonProps>) {
    return (
        <button className={styles.button + ' ' + className} onClick={onClick}>{children}<span className={styles.buttonBorder}></span></button>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/user-management-client/LoginComp.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/user-management-client/LoginComp.tsx
fileSize: 1752
replaced:
'use client'

import Input from "../Input";
import { SessionContext } from "../SessionContext";
import styles from './LoginComp.module.css'
import { LoginReq } from "./user-management-common/login";
import { userLoginFetch } from "./userManagementClient";
import { useEffect, useRef, useState } from "react";
import { LocalContext } from "../LocalContext";
import { login, userAndTokenToStorages } from "../userAndToken";
import Input2 from "../pr-client-utils/Input2";
import FixedAbortController from "../pr-client-utils/FixedAbortController";
import { isAbortError } from "../utils";

export interface LoginProps {
    user: string;
    setUser: (user: string) => void;
    passwd: string;
    setPasswd: (passwd: string) => void;
    onLoginClick: () => void;
    comment: string;
    spinning: boolean;
}

export default function LoginComp({ user, setUser, passwd, setPasswd, onLoginClick, comment, spinning }: LoginProps) {
    return <div className={styles.container}>
        <h2>Anmelden</h2>
        {/* <Input label='User' text={user} setText={setUser} onEnter={onLoginClick} /> */}
        <Input2 label='User' text={user} setText={setUser} onEnter={onLoginClick} />
        {/* <label className={styles.passwdLabel} htmlFor='passwd'>Passwort</label> */}
        {/* <input type='password' id='passwd' className={styles.passwd} value={passwd} onChange={(e) => setPasswd(e.target.value)} /> */}
        <Input2 type='password' label='Passwort' text={passwd} setText={setPasswd} onEnter={onLoginClick} />
        <button className={styles.loginButton} onClick={onLoginClick}>Login</button>
        <p className={styles.comment}>{comment}</p>
        {
            spinning &&
            <div className='loader'></div>
        }

    </div>
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/FormComp.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/FormComp.tsx
fileSize: 4182
replaced:
'use client'

import { PropsWithChildren, useEffect, useLayoutEffect, useRef, useState } from "react";
import styles from './FormComp.module.css'
import Image from "next/image";

export interface DecoImg {
    src: string;
    width: number;
    height: number;
    alt: string;
}

export interface FormProps {
    /**
     * default is 800
     */
    maxWidth?: number;
    /**
     * default is 600
     */
    maxHeight?: number;
    decoImg?: DecoImg;
}

export default function FormComp({ maxWidth, maxHeight, decoImg, children }: PropsWithChildren<FormProps>) {
    const [detectedWidth, setDetectedWidth] = useState<number>(Number.NaN);
    const [detectedHeight, setDetectedHeight] = useState<number>(Number.NaN);
    const divRef = useRef<HTMLDivElement>(null)
    const invisibleDivRef = useRef<HTMLDivElement>(null);

    useLayoutEffect(() => {
        function getDiv() {
            return divRef.current ?? invisibleDivRef.current;
        }
        let div = getDiv();
        if (div == null) throw new Error('divRef.current null');
        setDetectedWidth(div.clientWidth)
        setDetectedHeight(div.clientHeight);

        const resizeObserver = new ResizeObserver((entries, observer) => {
            if (div == null) return;
            const w = div.clientWidth;
            const h = div.clientHeight;
            if (w === 0 || h === 0) {
                const newDiv = getDiv();
                if (newDiv != null) {
                    resizeObserver.unobserve(div);
                    resizeObserver.observe(newDiv);
                    div = newDiv;
                }
            } else {
                setDetectedWidth(w);
                setDetectedHeight(h);
            }

        })
        resizeObserver.observe(div);

        return () => {
            if (div != null) {
                resizeObserver.unobserve(div)
            }
        }
    }, [])

    if (maxWidth == null) maxWidth = 800;
    if (maxHeight == null) maxHeight = 600;
    const layoutDone = !Number.isNaN(detectedWidth);
    const bigForImg = detectedWidth > maxWidth && detectedHeight > maxHeight;
    const big = detectedWidth > 500 && detectedHeight > 700;

    return (
        <>
            {layoutDone ?
                <div ref={divRef} className={styles.outer}>
                    {big ?
                        <>
                            {bigForImg && decoImg && <Image priority={true} className={styles.decoImg} src={decoImg.src} width={decoImg.width} height={decoImg.height} alt={decoImg.alt} />}
                            <div className={styles.bigInner} style={{
                                // width: `${maxWidth}px`,
                                // height: `${maxHeight}px`
                                minHeight: decoImg && decoImg.height + 'px'
                            }}>
                                {children}
                            </div>
                        </>
                        :
                        <div className={styles.smallInner}>
                            {children}
                        </div>
                    }
                </div>
                : <div className={styles.hiddenForLayout}>
                    <div ref={invisibleDivRef} className={styles.outer}>
                        {big ?
                            <>
                                {decoImg && <Image src={decoImg.src} width={decoImg.width} height={decoImg.height} alt={decoImg.alt} />}
                                <div className={styles.bigInner} style={{
                                    // width: `${maxWidth}px`,
                                    // height: `${maxHeight}px`
                                    minHeight: decoImg && decoImg.height + 'px'
                                }}>
                                    {children}
                                </div>
                            </>
                            :
                            <div className={styles.smallInner}>
                                {children}
                            </div>
                        }
                    </div>

                </div>
            }
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/CookieDlg.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/CookieDlg.tsx
fileSize: 1292
replaced:
import { useEffect, useState } from 'react';
import { withStopPropagation } from '../utils';
import styles from './CookieDlg.module.css';
import { LocalContext } from '../LocalContext';
import Privacy from '@/app/Privacy';

export interface CookieDlgProps {
    setCookiesAccepted: (accepted: boolean) => void;
}

/**
 * Dieser Dialog wird angezeigt, wenn im localStorage nicht bereits ein Eintrag vorliegt, dass dieser Dialog mit OK bestaetigt wurde.
 */
export default function CookieDlg({ setCookiesAccepted }: CookieDlgProps) {
    const [visible, setVisible] = useState(false);

    useEffect(() => {
        const ctx = new LocalContext();
        const ca = ctx.cookiesAccepted
        setVisible(!ca);
        setCookiesAccepted(ca);
    }, [setCookiesAccepted])

    function onOk() {
        const ctx = new LocalContext();
        setVisible(false);
        ctx.cookiesAccepted = true;
        setCookiesAccepted(true);
    }

    return (
        <>
            {visible &&
                <div className={styles.dlg}>
                    <Privacy />
                    <div className={styles.popupButtonRow}>
                        <button onClick={withStopPropagation(onOk)}>ZUSTIMMEN</button>
                    </div>
                </div>
            }        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/DateTimeInput.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/DateTimeInput.tsx
fileSize: 1766
replaced:
import { useCallback, useEffect, useState } from "react";
import Input from "../Input";
import { parseGermanDate, standardJavascriptDateTimeString } from "../utils";
import styles from './DateTimeInput.module.css'

export interface DateTimeInputProps {
    initialText: string;
    setDate: (d: Date | null) => void;
}
export default function DateTimeInput({initialText, setDate}: DateTimeInputProps) {
    const [text, setText] = useState(initialText);
    const [comment, setComment] = useState('');
    const [unclearMESZ, setUnclearMESZ] = useState(false);
    const [userMESZ, setUserMESZ] = useState(false);

    useEffect(() => {
        function extendedSetText(t: string) {
            const res = parseGermanDate(t);
            if (res == null) {
                setComment('Datum/Uhrzeit ungültig!');
                setDate(null);
                return;
            }
            if (Array.isArray(res)) {
                setUnclearMESZ(true);
                setComment('Sommerzeit nicht eindeutig, bitte prüfen')
                setDate(new Date(standardJavascriptDateTimeString(res[0], res[1], res[2], res[3], res[4], userMESZ)));
                return;
            }
            setUnclearMESZ(false);
            setUserMESZ(res.getTimezoneOffset() === -120);
            setComment('');
            setDate(res);
        }

        extendedSetText(text);
    }, [text, userMESZ, setDate])

    return (
        <div>
            <div><Input label='Datum/Uhrzeit (DD.MM.JJJJ hh:mm)' text={text} setText={setText} /> {comment}</div>
            <input readOnly={unclearMESZ} type='checkbox' checked={userMESZ} onChange={() => setUserMESZ(d => !d)} /><span className={unclearMESZ ? '' : styles.disabled } >Sommerzeit</span>
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/Impressum.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/Impressum.tsx
fileSize: 3904
replaced:
'use client'

import { useState } from 'react';
import styles from './Impressum.module.css'
import useUser from '../useUser';
import { withStopPropagation } from '../utils';
import Privacy from '@/app/Privacy';

export interface ImpressumProps {
    name: string;
    mail: string;
    phone: string;
    street: string;
    houseNr: string;
    postalCode: string;
    city: string;
    group: string | null;
    onDeleteClick: (() => void) | null;
}
export default function Impressum({ name, street, houseNr, mail, phone, postalCode, city, group, onDeleteClick }: ImpressumProps) {
    const [selfDeleted, setSelfDeleted] = useState(false);
    const user = useUser();

    function deleteMember() {
        if (onDeleteClick != null && confirm(`Achtung! Wirklich Daten zu deiner Mitgliedschaft in Gruppe "${group}" löschen? Nur dann OK klicken!`)) {
            onDeleteClick();
        }
    }

    function deleteUser() {
        if (onDeleteClick != null) {
            if (confirm(`Achtung! Wirklich Daten zu User "${user}" löschen?`)) onDeleteClick();
        } else {
            alert('Löschung gescheitert. :-(')
        }
    }

    return (
        <div className={styles.impressum}>
            <h1>Impressum</h1>
            <p>Angaben gemäß § 5 TMG:</p>
            <p>{name}<br />
                {street} {houseNr}<br />
                {postalCode} {city}</p>

            <p>Kontakt:</p>
            <p>Telefon: {phone}<br />
                E-Mail: <a href={`mailto:${mail}`}>{mail}</a></p>

            <p>Umsatzsteuer-ID:</p>
            <p>Umsatzsteuer-Identifikationsnummer gemäß §27a Umsatzsteuergesetz:<br />
                (keine da private Seite)</p>

            <p>Verantwortlich für den Inhalt nach § 55 Abs. 2 RStV:</p>
            <p>{name}<br />
                {street} {houseNr}<br />
                {postalCode} {city}</p>

            <p>Haftungsausschluss:</p>
            <p>Haftung für Inhalte<br />
                Die Inhalte unserer Seiten wurden mit größter Sorgfalt erstellt. Für die Richtigkeit, Vollständigkeit und Aktualität der Inhalte können wir jedoch keine Gewähr übernehmen.</p>

            <p>Haftung für Links<br />
                Unser Angebot enthält Links zu externen Webseiten Dritter, auf deren Inhalte wir keinen Einfluss haben. Deshalb können wir für diese fremden Inhalte auch keine Gewähr übernehmen. Für die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich.
            </p>
            <h1>Datenschutz</h1>
            <Privacy />
            {
                group != null &&
                <>
                    <p>Wenn du die App nicht mehr nutzen möchtest und alle Daten zu deiner Mitgliedschaft in der Gruppe {`"${group}"`} unmittelbar gelöscht werden sollen, bitte folgenden Button klicken:

                    </p>
                    <button onClick={withStopPropagation(deleteMember)} className={styles.delete}>
                        Ich möchte, dass nach dem Klick auf diesen Button alle Daten über mich in der Gruppe {`"${group}"`} gelöscht werden. Mir ist bewusst, dass dann alle anderen Gruppenmitglieder und -administratoren nichts mehr über mich in der App oder direkt in der Datenbank sehen können.
                    </button>
                </>
            }
            {
                user != null &&
                <>
                    <p>Wenn du die App nicht mehr nutzen möchtest und alle Daten zu deinem User {`"${user}"`} gelöscht werden sollen, bitte folgenden Button klicken:</p>
                    <button onClick={withStopPropagation(deleteUser)} className={styles.delete}>Ich möchte diese App nicht mehr nutzen und möchte dass mit dem Klick auf diesen Button unmittelbar alle Daten zu meinem User {`"${user}"`} gelöscht werden. </button>
                </>
            }
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/Toggler1.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/Toggler1.tsx
fileSize: 1466
replaced:
import { useId } from 'react';
import styles from './Toggler1.module.css'

export interface Toggler1Props {
    label?: string;
    checked: boolean
    setChecked: (checked: boolean) => void
}

export default function Toggler1({ label, checked, setChecked }: Toggler1Props) {
    const id = useId();
    return (
        <div className={styles.row}>
            <div className={styles.toggler}>
                <input tabIndex={0} id={id} type="checkbox" 
                checked={checked} onChange={() => { setChecked(!checked) }} />
                <label htmlFor={id}>
                    <svg className={styles.togglerOn} version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 130.2 130.2">
                        <polyline className={styles.path + ' ' + styles.check} points="100.2,40.2 51.5,88.8 29.8,67.5"></polyline>
                    </svg>
                    <svg className={styles.togglerOff} version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 130.2 130.2">
                        <line className={styles.path + ' ' + styles.line} x1="34.4" y1="34.4" x2="95.8" y2="95.8"></line>
                        <line className={styles.path + ' ' + styles.line} x1="95.8" y1="34.4" x2="34.4" y2="95.8"></line>
                    </svg>
                    <div className={styles.innerLabel}>{label}</div>
                </label>
            </div>
            {/* <div className={styles.labelText}>{label}</div> */}
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/Input2.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/Input2.tsx
fileSize: 2793
replaced:
'use client'

import { FocusEvent, useCallback, useEffect, useId, useRef, useState } from "react";

import styles from './Input2.module.css'

export interface Input2Props {
    label: string;
    text: string;
    setText: (text: string) => void;
    comment?: string;
    commentClass?: string;
    type?: 'text' | 'password' | 'email' | 'date' | 'datetime-local' | 'month' | 'number' | 'search' | 'tel' | 'time' | 'week';
    /**
     * 
     * @param text 
     * @returns '' if no error, other-wise error message
     */
    validate?: (text: string) => string;
    onEnter?: () => void;
}
export default function Input2({ label, text, setText, comment, commentClass, type, validate, onEnter }: Input2Props) {
    const inputRef = useRef<HTMLInputElement>(null)
    const [focussed, setFocussed] = useState(false);
    const [validationMessage, setValidationMessage] = useState('');

    function onFocus() {
        setFocussed(true)
    }
    function onBlur(e: FocusEvent<HTMLInputElement>) {
        if (inputRef.current != null) {
            const error = (validate && validate(text)) ?? '';
            inputRef.current.setCustomValidity(error);
            setValidationMessage(error);
            // if (error !== '') {
            // inputRef.current.reportValidity()
            // }
        }
        setFocussed(false)
    }

    const doValidate = useCallback((s: string) => {
        const error = (validate && validate(s)) ?? '';
        inputRef.current?.setCustomValidity(error);
        setValidationMessage(error);
        // if (error !== '') inputRef.current?.reportValidity();
    }, [validate])

    useEffect(() => {
        doValidate(text)
    }, /* [text, doValidate] */)

    const onEnterIntern = useCallback(() => {
        doValidate(text)
        if (inputRef.current?.validationMessage) {
            inputRef.current?.reportValidity()
        } else {
            inputRef.current?.blur();
            if (onEnter) onEnter();
        }
    }, [doValidate, text, onEnter])

    const id = useId();
    const empty = text === '' && !focussed && !['month', 'date', 'week', 'datetime-local'].includes(type ?? 'text');

    return (
        <>
            <div className={styles.box}>
                <label htmlFor={id} className={empty ? styles.empty : ''}>{label}</label>
                <input ref={inputRef} id={id} type={type ?? 'text'} spellCheck={false} value={text} onChange={(e) => { setText(e.target.value); doValidate(e.target.value) }} onFocus={onFocus} onBlur={onBlur} onKeyUp={(e) => {
                    if (e.key === 'Enter') onEnterIntern();
                }} />
                <div className={`${commentClass} ${styles.comment}`}>{(comment == null ? '' : comment + '-') + (validationMessage)}</div>
            </div>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/AccordionPage.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/AccordionPage.tsx
fileSize: 1126
replaced:
import { PropsWithChildren, useContext } from "react";
import { accordionContext } from "./AccordionContext";
import styles from './AccordionPage.module.css'
import Image from "next/image";

export interface AccordionPageProps {
    header: string;
}

export default function AccordionPage({ children, header }: PropsWithChildren<AccordionPageProps>) {
    const ctx = useContext(accordionContext)
    console.log('ctx', ctx);
    const pageOpen = ctx.open.includes(ctx.ownIdx);
    console.log('pageOpen', pageOpen)
    return (
        <>
            <div className={pageOpen ? styles.hdOpen : styles.hdClosed} onClick={ctx.toggleOwnOpen ?? undefined}>
                <div>{pageOpen ? '-' : '+'}</div>
                <div className={styles.hdText}>
                    {header}
                </div>
                <Image src='/down-chevron_9144316.png' alt='Open' width={32} height={32} />
            </div>
            {
                pageOpen && (
                    <div className={styles.content}>
                        {children}
                    </div>
                )
            }
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/Accordion.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/Accordion.tsx
fileSize: 974
replaced:
import { PropsWithChildren } from "react"
import { accordionContext } from "./AccordionContext"
import useAccordion from "./useAccordion"

export interface AccordionPage {

}
export interface AccordionProps {
    multiOpen: boolean;
    defaultOpen?: number | number[];
}

export default function Accordion({ children, multiOpen, defaultOpen }: PropsWithChildren<AccordionProps>) {
    const [open, toggleOpen] = useAccordion(multiOpen, defaultOpen ?? [])
    return (
        <>
            <div>

                {Array.isArray(children) ? children.map((child, i) => (
                    <accordionContext.Provider key={i} value={{ 
                        ownIdx: i,
                        open: open,
                        toggleOwnOpen: () => {
                            toggleOpen(i)
                        } }}>
                        {child}
                    </accordionContext.Provider>
                )) : <></>}
            </div>
        </>
    )
}


path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/EditableOptionalDateTimeComp.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/EditableOptionalDateTimeComp.tsx
fileSize: 5904
replaced:
import Checkbox from "../Checkbox";
import { EditableOptionalDateTimeProps } from "./useEditableOptionalDateTime";
import styles from './EditableOptionalDateTimeComp.module.css'
import Label from "../Label";
import { Dispatch, KeyboardEvent, SetStateAction, useEffect, useRef, useState } from "react";
import Image from "next/image";
import { Popup } from "@/app/Popup";
import { formatDateTime, withStopPropagation } from "../utils";
import Input from "../Input";
import Input2 from "./Input2";
import Toggler1 from "./Toggler1";

export interface EditableOptionalDateTimeCompProps {
    label: string;
    info?: string;
    enabled: boolean;
    setEnabled: (enabled: boolean) => void;
    editedText: string;
    setEditedText: Dispatch<SetStateAction<string>>;
    editing: boolean;
    setEditing: Dispatch<SetStateAction<boolean>>;
    onOk: () => void;
    onCancel: () => void;
    unclearMESZ: boolean;
    userMESZ: boolean;
    setUserMESZ: Dispatch<SetStateAction<boolean>>;
    error: string;
    optionalMs: number | null;
}
export default function EditableOptionalDateTimeComp({ label, info, enabled, setEnabled, editedText, setEditedText,
    editing, setEditing, onOk, onCancel, unclearMESZ, userMESZ, setUserMESZ, error, optionalMs }: EditableOptionalDateTimeCompProps) {

    const [infoVisible, setInfoVisible] = useState(false)
    const dialogRef = useRef<HTMLDialogElement>(null)
    const inputRef = useRef<HTMLInputElement>(null);
    const divRef = useRef<HTMLDivElement>(null);
    const addedCloseListenerRef = useRef<((ev: Event) => any) | null>(null);

    useEffect(() => {
        if (editing && dialogRef.current != null) {
            dialogRef.current.addEventListener('close', addedCloseListenerRef.current = ((e: Event) => {
                if (addedCloseListenerRef.current != null) {
                    dialogRef.current?.removeEventListener('close', addedCloseListenerRef.current);
                    setEditing(false);
                }
            }))
            dialogRef.current.showModal();
        }
        if (!editing && dialogRef.current != null) {
            dialogRef.current.close();
            divRef.current?.focus()
        }
    }, [editing, setEditing])

    const comment = unclearMESZ ? 'Sommerzeit nicht eindeutig, bitte prüfen' : '';
    return (
        <>
            <Checkbox
                label={label}
                checked={enabled}
                setChecked={setEnabled}
            />
            {
                Number.isSafeInteger(optionalMs) && enabled &&
                <>
                    {/* <div className={styles.labelAndInfo}>
                        {label != null && <Label>{label}</Label>}
                        {
                            info != null &&
                            <>
                                <button className={styles.infoButton}
                                    onClick={() => setInfoVisible(true)}>
                                    <Image src='/information-point_72168.png' width={32} height={32} alt='Info' />
                                </button>
                                <Popup visible={infoVisible} setVisible={setInfoVisible}>
                                    <p className={styles.info}>{info}</p>
                                </Popup>
                            </>
                        }
                    </div> */}

                    <dialog ref={dialogRef} className='form'>
                        {/* <Label>{label}</Label> */}
                        <div>
                            {/* <div><Input ref={inputRef} label='Datum/Uhrzeit (DD.MM.JJJJ hh:mm)' text={editedText} setText={setEditedText} onEnter={onOk} /> <div className={styles.comment}>{comment}</div></div> */}
                            <Input2 label={label} text={editedText} setText={setEditedText} onEnter={onOk} validate={(text) => {
                                return error
                            }} />
                            <div className={styles.summerWinter}>
                            {
                                unclearMESZ ?
                                <label className={styles.label}><input tabIndex={unclearMESZ ? 0 : -1} readOnly={!unclearMESZ} type='checkbox' checked={userMESZ} onChange={() => setUserMESZ(d => !d)} /><span className={unclearMESZ ? '' : styles.disabled} >Sommerzeit</span></label> :
                                <p>({userMESZ ? 'Sommerzeit' : 'Winterzeit'})</p>
                            }
                            </div>
                        </div>

                        {/* <div className={styles.error}>
                            {
                                error !== '' &&
                                <p className={styles.error}>{error}</p>
                            }
                        </div> */}
                        <div className={styles.buttonRow}>
                            {!error &&
                                <button className={styles.okImg} onClick={withStopPropagation(onOk)}></button>}
                            <button className={styles.cancelImg} onClick={withStopPropagation(onCancel)}></button>
                        </div>
                    </dialog>

                    <div className={`${styles.content} scrollableHor`} style={{ minHeight: '40px', margin: '4px' }} role='button' tabIndex={0} ref={divRef} onKeyUp={(e: KeyboardEvent<HTMLDivElement>) => {
                        e.stopPropagation()
                        let f = () => { }
                        switch (e.key) {
                            case 'Enter': case ' ':
                                setEditing(true);
                                break;
                        }
                    }} onClick={withStopPropagation(() => { setEditing(true) })}>{formatDateTime(optionalMs, true)}</div>

                </>
            }
        </>
    )

}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/ScrollableContainer.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/pr-client-utils/ScrollableContainer.tsx
fileSize: 5866
replaced:
'use client'

import { PropsWithChildren, useCallback, useEffect, useRef, useState } from 'react';
import styles from './ScrollableContainer.module.css'
import { ScrollableContainerProps } from './ScrollableContainerProps';
import { withStopPropagation } from '../utils';

const childWidth = 80;

function Point({ selected, onPointClick, onEnterDown }: {
    selected: boolean; onPointClick?: () => void;
    onEnterDown?: () => void;
}) {
    const canvasRef = useRef<HTMLCanvasElement>(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (canvas == null || !canvas.getContext) return;
        const c = canvas.getContext('2d')
        if (c == null) return
        c.fillStyle = selected ? 'lightgray' : 'gray';
        c.arc(8, 8, 8, 0, Math.PI * 2)
        c.fill()
    }, [selected])

    return <canvas ref={canvasRef} className={styles.point} width={16} height={16} tabIndex={0} onClick={onPointClick && withStopPropagation(onPointClick)} onKeyDown={(e) => {
        if (e.key === 'Enter' && onEnterDown) onEnterDown();
    }} />
}

export default function ScrollableContainer({ className, snapOffset, snapWidth, snap, setSnap, children, points }: PropsWithChildren<ScrollableContainerProps>) {
    const timeoutRef = useRef<NodeJS.Timeout | null>(null)
    const containerRef = useRef<HTMLDivElement>(null);
    const [mySnapWidth, setMySnapWidth] = useState<number | null>(snapWidth ?? null)
    const [dummyWidth, setDummyWidth] = useState<number | null>(null);


    useEffect(() => {
        const container = containerRef.current
        if (dummyWidth != null || container == null) {
            return;
        }
        const clientWidth = container.clientWidth;
        // Goal: snapOffset + mySnapWidth + dummyWidth = clientWidth
        // So dummyWidth := clientWidth - snapOffset - mySnapWidth
        const newSnapWidth = snapWidth ?? clientWidth;
        setMySnapWidth(newSnapWidth)
        const d = clientWidth - (snapOffset ?? 0) - newSnapWidth
        setDummyWidth(d);
    }, [dummyWidth, snapWidth, snapOffset])

    useEffect(() => {
        const container = containerRef.current
        if (container == null) {
            return
        }
        const resizeObserver = new ResizeObserver((entries, observer) => {
            const clientWidth = container.clientWidth;
            // Goal: snapOffset + mySnapWidth + dummyWidth = clientWidth
            // So dummyWidth := clientWidth - snapOffset - mySnapWidth
            const newSnapWidth = snapWidth ?? clientWidth;
            if (newSnapWidth !== snapWidth) {
                setMySnapWidth(newSnapWidth)
            }
            const d = clientWidth - (snapOffset ?? 0) - newSnapWidth
            setDummyWidth(d);
        })

        resizeObserver.observe(container)

        return () => {
            resizeObserver.unobserve(container)
        }

    }, [snapOffset, snapWidth])

    useEffect(() => {
        const container = containerRef.current;
        if (snap == null || container == null || dummyWidth == null || mySnapWidth == null) return;
        container.scrollLeft = snap * mySnapWidth;
    }, [snap, children, snapWidth, dummyWidth, mySnapWidth])

    const childrenLen = Array.isArray(children) ? children.length : 1

    const innerWidth = (snapOffset ?? 0) + childrenLen * (mySnapWidth ?? 0) + (dummyWidth ?? 0);

    return (
        <div className={`${styles.outer} ${className}`}>
            <div ref={containerRef} className={`${styles.container}`} onScroll={(e) => {
                if (timeoutRef.current != null) {
                    clearTimeout(timeoutRef.current);
                }
                if (mySnapWidth == null || snapOffset == null) return;

                timeoutRef.current = setTimeout(() => {
                    if (containerRef.current == null) return;
                    const scrollLeft = containerRef.current.scrollLeft;
                    const snap = Math.round((scrollLeft /* - (snapOffset ?? 0) */) / mySnapWidth);
                    if (snap >= 0 && snap < childrenLen) {
                        containerRef.current.scrollLeft = snap * mySnapWidth;
                        if (setSnap != null) {
                            setSnap(snap);
                        }
                    }
                }, 200)
            }} >
                <div style={{
                    width: `${innerWidth}px`
                }} className={styles.inner}>
                    {
                        snapOffset != null && <div><div style={{ width: snapOffset }}></div></div>
                    }
                    {Array.isArray(children) && children.map((child, i) =>
                        <div key={i} style={{ width: `${mySnapWidth}px` }}>
                            {child}
                        </div>
                    )}
                    {
                        dummyWidth != null && dummyWidth > 0 &&
                        <div>
                            <div style={{ width: dummyWidth }}></div>
                        </div>
                    }
                    {/* {
                        snapOffset != null && mySnapWidth != null &&
                        <div>
                            <div style={{ width: `${mySnapWidth}px` }}></div>
                        </div>
                    } */}
                </div>
            </div>
            {
                points && snap != null &&
                <div className={styles.points}>
                    {Array.isArray(children) ? children.map((c, i) => {
                        return <Point key={i} selected={i === snap} onPointClick={() => { if (setSnap != null) setSnap(i) }}
                            onEnterDown={() => { if (setSnap != null) setSnap(i) }} />
                    }) : <span>kein Array?!</span>}
                </div>
            }
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/EscapableComp.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/EscapableComp.tsx
fileSize: 627
replaced:
'use client'

import { KeyboardEventHandler, PropsWithChildren } from "react";

export interface EscapableProps {
    onCancel: () => void;
    className: string;
}

export default function EscapableComp(props: PropsWithChildren<EscapableProps>): React.ReactElement<EscapableProps> {

    const onKeyDown: KeyboardEventHandler<HTMLDivElement> = (e) => {
        if (e.key === 'Escape') {
            props.onCancel();
            e.stopPropagation();
            e.preventDefault();
        }
    }
    return (
        <div className={props.className} onKeyDown={onKeyDown}>
            {props.children}
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/TabButton.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/TabButton.tsx
fileSize: 474
replaced:
import styles from './TabButton.module.css'

export interface TabButtonProps {
    label: string;
    ownKey: string;
    selectedKey: string;
    setSelectedKey: (key: string) => void;
}
export default function TabButton({label, ownKey, selectedKey, setSelectedKey}: TabButtonProps) {
    return (
        <div className={`${styles.tabButton} ${selectedKey === ownKey && styles.selected}`} onClick={() => setSelectedKey(ownKey)}>
            {label}
        </div>
    )

}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/TabPage.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/TabPage.tsx
fileSize: 404
replaced:
import { PropsWithChildren } from 'react'
import styles from './TabPage.module.css'

export interface TabPageProps {
    ownKey: string;
    selectedKey: string;
}
export default function TabPage({ ownKey, selectedKey, children }: PropsWithChildren<TabPageProps>) {
    return (
        <>
            {
                ownKey === selectedKey &&
                children
            }
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/Header.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/Header.tsx
fileSize: 1330
replaced:
import Profile from "./Profile";
import styles from './Header.module.css'
import { HeaderLine } from "./HeaderLine";
import { ImgData } from "./api";

export interface HeaderProps {
    user: string | null;
    logo?: ImgData;
    line1: HeaderLine;
    margin: string;
    line2: HeaderLine;
}

export default function Header({ user, logo, line1, margin, line2 }: HeaderProps) {
    return (
        <>
            <Profile user={null} logo={logo} />
            <div className={styles.lines}>
                <div style={{ marginLeft: logo != null ? '60px' : '0' }}>
                    <div style={{
                        margin: '0',
                        fontSize: line1.fontSize,
                        fontWeight: line1.bold ? 'bold' : 'normal'

                    }}>{line1.text}</div>
                    <div style={{
                        margin: '0',
                        marginTop: margin,
                        fontSize: line2.fontSize,
                        fontWeight: line2.bold ? 'bold' : 'normal'
                    }}>{line2.text}</div>
                    <div style={{
                        marginLeft: '2rem',
                        marginTop: '1rem',
                        color: 'gray'
                    }}>{user}</div>
                </div>
            </div >
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/clientUtils.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/clientUtils.tsx
fileSize: 7008
replaced:
'use client'

import { useState, useRef, useCallback, useEffect, KeyboardEvent } from "react";
import { Popup } from "../Popup";
import Label from "./Label";
import { withStopPropagation } from "./utils";
import Image from "next/image";

import styles from './clientUtils.module.css'
import Input2 from "./pr-client-utils/Input2";

export type Validation = 'validating' | 'valid' | 'invalid'

export interface EditableProps<T> {
    disabled?: boolean
    label?: string
    info?: string;
    value: T
    setValue: (t: T) => void
    format: (t: T) => string
    /**
     * 
     * @param s text to be parsed and checked
     * @returns object of type T or raises an error string that is shown in the editor
     */
    parse: (s: string) => Promise<T>
}

export function Editable<T>({ disabled, label, info, value, setValue, format, parse }: EditableProps<T>) {
    const [editing, setEditing] = useState(false)
    const [validation, setValidation] = useState<Validation>('valid');
    const [error, setError] = useState<string>('')
    const [editedText, setEditedText] = useState('')
    const inputRef = useRef<HTMLInputElement>(null)
    const divRef = useRef<HTMLDivElement>(null)
    const dialogRef = useRef<HTMLDialogElement>(null)
    // const popoverRef = useRef<HTMLDivElement>(null)
    const wasEditingRef = useRef<boolean>(false)
    const [infoVisible, setInfoVisible] = useState(false)
    const [editPos, setEditPos] = useState<{ x: number; y: number }>({ x: 0, y: 0 })

    function onEditClick() {
        if (disabled) return;
        setEditing(true);
        if (dialogRef.current == null) throw new Error('dialogRef.current null')
        dialogRef.current.showModal()
        // if (popoverRef.current != null) {
        //     console.log('added popover toggle event listener')
        //     popoverRef.current.showPopover();
        // }
        setEditedText(format(value))
    }

    function onChange(s: string) {
        setEditedText(s);
        setValidation('validating');
        setError('');
        parse(s).then(value => {
            setValidation('valid');
        }).catch((s: any) => {
            setValidation('invalid')
            if (typeof s === 'string') {
                setError(s);
            } else {
                console.error(s);
            }
        })
    }

    const closeDialog = useCallback(() => {
        if (dialogRef.current == null) return;
        dialogRef.current.close();
        // if (popoverRef.current != null) {
        //     popoverRef.current.hidePopover()

        // }
        setEditing(false);
    }, [])

    function onCancel() {
        if (!editing) return;
        closeDialog();
        setValidation('valid');
        setError('')
    }

    function onOk() {
        if (!editing) return;
        parse(editedText).then(val => {
            setValue(val)
            closeDialog();
        }).catch((s: any) => {
            setValidation('invalid')
            if (typeof s === 'string') {
                setError(s);
            } else {
                console.error(s);
            }
        })
    }

    useEffect(() => {
        if (editing && inputRef.current != null) {
            inputRef.current.focus();
            wasEditingRef.current = true;
        } else if (wasEditingRef.current && !editing && divRef.current != null) {
            divRef.current.focus();
            wasEditingRef.current = false;
        }
    }, [editing])



    return (
        <>
            {
                (label != null || info != null) &&
                <div className={styles.labelAndInfo}>
                    <Label>{label}</Label>
                    {
                        info != null &&
                        <>
                            <button className={styles.infoButton}
                                onClick={() => setInfoVisible(true)}>
                                <Image src='/information-point_72168.png' width={32} height={32} alt='Info' />
                            </button>
                            <Popup visible={infoVisible} setVisible={setInfoVisible}>
                                <p className={styles.info}>{info}</p>
                            </Popup>
                        </>
                    }
                </div>
            }            {/* <button popovertarget='testpopover'>Control popover</button>
            <div ref={popoverRef} id='testpopover' popover='manual' onpopover>
                (popover)
                <input autoFocus className={styles.input} ref={inputRef} value={editedText} onChange={(e) => onChange(e.target.value)} onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                        onOk()
                    } else if (e.key === 'Escape') {
                        onCancel();
                    }
                }} />
                {
                    error !== '' &&
                    <p className={styles.error}>{error}</p>
                }
                <div className={styles.buttonRow}>
                    {validation === 'valid' &&
                        <button className={styles.okImg} onClick={withStopPropagation(onOk)}></button>}
                    <button className={styles.cancelImg} onClick={withStopPropagation(onCancel)}></button>
                </div>
            </div> */}
            <dialog onClose={() => { onCancel(); }} className='form' ref={dialogRef} aria-modal>
                {/* <Label>{label}</Label>
                <input autoFocus className={styles.input} ref={inputRef} value={editedText} onChange={(e) => onChange(e.target.value)} onKeyUp={(e) => {
                    if (e.key === 'Enter') {
                        onOk()
                    } else if (e.key === 'Escape') {
                        onCancel();
                    }
                }} /> */}
                <Input2 label={label ?? ''} text={editedText} setText={onChange} onEnter={onOk} validate={(text) => {
                    return error
                }} />
                {/* {
                    error !== '' &&
                    <p className={styles.error}>{error}</p>
                } */}
                <div className={styles.buttonRow}>
                    {validation === 'valid' &&
                        <button className={styles.okImg} onClick={withStopPropagation(onOk)}></button>}
                    <button className={styles.cancelImg} onClick={withStopPropagation(onCancel)}></button>
                </div>
            </dialog>
            <div className={`${styles.content} scrollableHor`} role='button' tabIndex={0} ref={divRef} onKeyUp={(e: KeyboardEvent<HTMLDivElement>) => {
                e.stopPropagation()
                let f = () => { }
                switch (e.key) {
                    case 'Enter': case ' ':
                        onEditClick();
                        break;
                }
            }} onClick={disabled ? undefined : withStopPropagation(onEditClick)}>{format(value)}</div>
        </>
    )
}


path: "/home/peter/my_projects/individual-gits/pr-groups/app/_lib/Profile.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/_lib/Profile.tsx
fileSize: 595
replaced:
import Image from 'next/image';
import styles from './Profile.module.css'
import { ImgData } from './api';

export interface ProfileProps {
    user: string | null;
    logo?: ImgData;
}

export default function Profile({ user, logo }: ProfileProps) {
    return (
        <>
            {logo != null &&
                <div className={styles.logo}>
                    <Image src={logo.src} alt={logo.alt} width={logo.width} height={logo.height} />

                </div>
            }
            <div className={styles.profile}>
                {user}
            </div>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/layout.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/layout.tsx
fileSize: 1316
replaced:
import type { Metadata, Viewport } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import Image from "next/image";
import 'bootstrap/dist/css/bootstrap.min.css';

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "pr-groups",
  description: "Light groups and activities management system",
};

export const viewport: Viewport = {
  width: 'device-width',
  initialScale: 1
  // initialScale: 1
  // initialScale: 0.86,
  // minimumScale: 0.86,
  // maximumScale: 5
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {


  // return (
  //   <html lang="de">
  //     <body className={inter.className}>
  //       <div className='d1'>
  //         <div className='d5'>
  //           <div className='d6'>
  //           </div>
  //           <div id='d4' className='d4'>
  //             d4
  //           </div>
  //         </div>
  //         <div className='d2'>
  //         </div>
  //         <div className='d3'>
  //           {children}
  //         </div>
  //       </div>
  //     </body>
  //   </html>
  // );

  return (
    <html lang="de">
      <body className={inter.className}>
        <div className='d1'>
          {children}
        </div>
      </body>
    </html>
  );
}


path: "/home/peter/my_projects/individual-gits/pr-groups/app/testScrollableContainer2/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/testScrollableContainer2/page.tsx
fileSize: 748
replaced:
'use client'

import { useState } from "react";
import ScrollableContainer from "../_lib/pr-client-utils/ScrollableContainer";
import styles from './page.module.css'

export default function Page() {
    const [snap, setSnap] = useState(0);

    const buttons = []

    for (let i = 0; i < 100; ++i) {
        buttons.push(<button key={i}>Button {i}</button>)
    }

    return (
        <ScrollableContainer className={styles.container} points snap={snap} setSnap={setSnap} snapWidth={260} snapOffset={0}>
            <div className={styles.page}>
                page 1
            </div>
            <div className={styles.page}>
                <h1>page 2</h1>
                {buttons}
            </div>
        </ScrollableContainer>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/testScrollableContainer/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/testScrollableContainer/page.tsx
fileSize: 1174
replaced:
'use client'

import { ReactNode, useRef, useState } from 'react'
import ScrollableContainer from '../_lib/pr-client-utils/ScrollableContainer'
import styles from './page.module.css'

interface ChildProps {
    idx: number;
}
function ChildComp({ idx }: ChildProps) {
    return (
        <div>
            <div className={styles.childInner}>{idx}</div>
        </div>
    )
}

export default function Page() {
    const [scrollX, setScrollX] = useState(0);
    const testDiv = useRef<HTMLDivElement>(null)

    const children1: ReactNode[] = []

    for (let i = 0; i < 100; ++i) {
        children1.push(<ChildComp key={i} idx={i} />)
    }
    // 18
    return (
        <ScrollableContainer snapOffset={80 - 18} snapWidth={80} className={styles.container}>
            {children1}
        </ScrollableContainer>
        // <>
        //     scrollX: {scrollX}
        //     <div ref={testDiv} className={styles.container + ' ' + styles.test} onScroll={() => {
        //         if (testDiv.current == null)return;
        //         setScrollX(testDiv.current.scrollLeft)
        //     }} >
        //         {children1}
        //     </div>
        // </>

    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/group/member/add/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/group/member/add/page.tsx
fileSize: 3840
replaced:
'use client'

import Profile from "@/app/_lib/Profile";
import useUser from "@/app/_lib/useUser"
import styles from './page.module.css'
import { useState } from "react";
import { SessionContext } from "@/app/_lib/SessionContext";
import { GroupMemberAddReq, GroupMemberAddResp } from "@/app/_lib/api";
import { apiFetchPost } from "@/app/_lib/user-management-client/apiRoutesClient";
import Input from "@/app/_lib/Input";
import Header from "@/app/_lib/Header";
import { userAndTokenFromStorages } from "@/app/_lib/userAndToken";

export default function Page() {
    const user = useUser();
    const [group, setGroup] = useState('')
    const [newPhoneNr, setNewPhoneNr] = useState('');
    const [prename, setPrename] = useState('');
    const [surname, setSurname] = useState('');
    const [comment, setComment] = useState('');
    const [invitationLink, setInvitationLink] = useState<string | null>(null);
    const [copied, setCopied] = useState(false);

    async function onAddClick() {
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            setComment('Du bist nicht eingeloggt.')
            return;
        }
        const req: GroupMemberAddReq = {
            user: user1,
            token: token1,
            group: group,
            phoneNr: newPhoneNr,
            prename: prename,
            surname: surname,
        }
        setComment('Sende Daten ...');
        setInvitationLink(null);
        setCopied(false);
        const resp = await apiFetchPost<GroupMemberAddReq, GroupMemberAddResp>('/api/group/member/add', req)
        switch (resp.type) {
            case 'authFailed':
                setComment('Nicht authorisiert.');
                break;
            case 'success':
                setComment(`Einladungslink für ${prename} ${surname}: ${location.origin + resp.invitationUrl}`)
                setInvitationLink(location.origin + resp.invitationUrl);
                break;
            case 'groupNotFound':
                setComment(`Gruppe ${group} existiert nicht.`);
                break;
            case 'phoneNrContained':
                setComment(`Abgebrochen. Es gibt bereits ein Mitglied mit Telefonnr ${newPhoneNr} in Gruppe ${group}.`)
                break;
            case 'error':
                setComment(`Unerwarteter Fehler: ${resp.error}`);
                break;
        }
    }

    function onCopyClick() {
        if (invitationLink == null) return;
        navigator.clipboard.writeText(invitationLink).then(() => {
            setCopied(true);
        })
    }

    return (
        <>
            <Header user={user} line1={{ text: 'pr-groups / Gruppenadmin', fontSize: '1.2em', bold: false }} margin='1em' line2={{ text: 'Gruppenmitglied hinzufügen', fontSize: '1.5em', bold: true }} />
            <Profile user={user} />
            <div className={styles.form}>
                <Input label='Gruppe' text={group} setText={setGroup} />
                <Input label='Telefonnr. des neuen Gruppenmitglieds' text={newPhoneNr} setText={setNewPhoneNr} />
                <Input label='Vorname des neuen Mitglieds' text={prename} setText={setPrename} />
                <Input label='Nachname (ggf. Kürzel) des neuen Mitglieds' text={surname} setText={setSurname} />
                <button className={styles.addButton} disabled={user == null} onClick={onAddClick}>Gruppenmitglied hinzufügen</button>
                <p>{comment}</p>
                {invitationLink != null &&
                    <div className={styles.copyLink}>
                        <textarea readOnly value={invitationLink} />
                        <button className={`${styles.copy} ${copied && styles.copied}`} onClick={onCopyClick} />
                    </div>
                }
            </div>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/group/activity/add/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/group/activity/add/page.tsx
fileSize: 5493
replaced:
'use client'

import Profile from "@/app/_lib/Profile";
import useUser from "@/app/_lib/useUser"
import styles from './page.module.css'
import { useState } from "react";
import Input from "@/app/_lib/Input";
import { apiFetchPost } from "@/app/_lib/user-management-client/apiRoutesClient";
import { GroupActivityAddReq, GroupActivityAddResp } from "@/app/_lib/api";
import { SessionContext } from "@/app/_lib/SessionContext";
import Header from "@/app/_lib/Header";
import { parseGermanDate } from "@/app/_lib/utils";
import DateTimeInput from "@/app/_lib/pr-client-utils/DateTimeInput";
import { userAndTokenFromStorages } from "@/app/_lib/userAndToken";
import Menu, { CustomMenuItem } from "@/app/_lib/Menu";
import useLoginLogout from "@/app/_lib/useLoginLogout";
import FormComp from "@/app/_lib/pr-client-utils/FormComp";
import Input2 from "@/app/_lib/pr-client-utils/Input2";
import { Popup } from "@/app/Popup";
import LoginComp from "@/app/_lib/user-management-client/LoginComp";

export default function Page() {
    const [group, setGroup] = useState('');
    const [activity, setActivity] = useState('');
    const [capacity, setCapacity] = useState('');
    // const [date, setDate] = useState<Date | null>(null);
    const [timeText, setTimeText] = useState('');
    const [comment, setComment] = useState('');
    const [unclearMESZ, setUnclearMESZ] = useState(false);
    const [cookiesAccepted, setCookiesAccepted] = useState(false);
    const [user, onLoginClick, onLogoutClick, loginLogoutSpinning, userText, setUserText, passwdText, setPasswdText, loginError, logoutError] = useLoginLogout()

    async function onAddClick() {
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            setComment('Bitte erst einloggen.');
            return;
        }

        setComment('Erstelle Aktivität ...');
        let capacityNum: number | null = null;
        try {
            capacityNum = parseInt(capacity);
        } catch (reason) { }
        const date = new Date(timeText);
        const req: GroupActivityAddReq = {
            user: user1,
            token: token1,
            group: group,
            activity: activity,
            date: date?.getTime() ?? null,
            capacity: capacityNum != null && capacityNum > 0 ? capacityNum : null
        }
        const resp = await apiFetchPost<GroupActivityAddReq, GroupActivityAddResp>('/api/group/activity/add', req);
        switch (resp.type) {
            case 'authFailed':
                setComment('Nicht authorisiert.');
                break;
            case 'success':
                setComment(`Aktivität "${activity}" in Gruppe "${group}" erstellt.`);
                break;
            case 'groupNotFound':
                setComment(`Gruppe "${group}" nicht gefunden.`);
                break;
            case 'wasActivity':
                setComment(`Es gibt bereits die Aktivität "${activity}" in Gruppe "${group}".`);
                break;
            case 'error':
                setComment(`Unerwarteter Fehler: ${resp.error}`);
                break;
        }
    }

    const customMenuItems: CustomMenuItem[] = user == null ? [] : [
        {
            type: 'normal',
            label: `${user} abmelden`,
            onClick: onLogoutClick
        }
    ]

    return (
        <>
            <Menu customSpinning={false} setCookiesAccepted={setCookiesAccepted} customItems={customMenuItems} >
                <Header user={null} line1={{ text: 'pr-groups / Gruppen-Admin', 
                    fontSize: '1.2rem', bold: false }} 
                    margin='1rem' 
                    line2={{ text: 'Aktivität hinzufügen', fontSize: '1.5rem', bold: true }} />
                <div className={styles.main}>
                    <FormComp decoImg={{ src: '/group-friends-jumping-top-hill.jpg', alt: 'Gruppe', width: 714, height: 576 }} maxWidth={1280} >
                        <div className={styles.form}>
                            <Input2 label='Gruppe' text={group} setText={setGroup} />
                            <Input2 label='Aktivität' text={activity} setText={setActivity} />
                            <Input2 type='number' label='Teilnehmerkapazität' text={capacity} setText={setCapacity} validate={(text) => {
                                if (text === '') return '';
                                const n = parseInt(text);
                                if (n < 1) return 'Mindestens 1!'
                                if (isNaN(n)) return 'Zahl eingeben!'
                                return '';
                            }} />
                            {/* <DateTimeInput initialText='' setDate={setDate} /> */}
                            <Input2 type='datetime-local' label='Uhrzeit' text={timeText} setText={setTimeText} />
                            <button className={styles.addButton} onClick={onAddClick}>Aktivität hinzufügen</button>
                            <p className={styles.comment}>
                                {comment}
                            </p>
                        </div>
                    </FormComp>
                </div>
                <Popup visible={user == null}>
                    <LoginComp user={userText} setUser={setUserText} passwd={passwdText} setPasswd={setPasswdText} comment={loginError} onLoginClick={onLoginClick} spinning={loginLogoutSpinning} />
                </Popup>
            </Menu>

        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/tests/testAccordion/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/tests/testAccordion/page.tsx
fileSize: 1944
replaced:
'use client'

import Accordion from "@/app/_lib/pr-client-utils/Accordion";
import AccordionPage from "@/app/_lib/pr-client-utils/AccordionPage";
import BootstrapAccordion from "./BootstrapAccordion";
import Container from "react-bootstrap/Container";
import Form from "react-bootstrap/Form";
import FormControl from "react-bootstrap/FormControl";
import InputGroup from "react-bootstrap/InputGroup";
import Button from "react-bootstrap/Button";
import { useState } from "react";

export default function Page() {
    const [x, setX] = useState<number>(0);
    const [checked, setChecked] = useState(false)
    console.log('checked', checked, 'x', x);
    return (
        <Container >
            <Button >test button</Button>
            <Accordion multiOpen={false}>
                <AccordionPage header="Page 1">
                    <h1>Content page 1</h1><p>bla bla</p>
                </AccordionPage>
                <AccordionPage header="Page 2">
                    <h1>Content page 2</h1><p>More bla bla</p>
                </AccordionPage>
            </Accordion>
            <Accordion multiOpen={true} defaultOpen={[0]}>
                <AccordionPage header='Multi 1'>
                    Erst einmal bla bla
                </AccordionPage>
                <AccordionPage header='Multi 2'>
                    Dann aber bla bla
                </AccordionPage>
            </Accordion>

            <Form className='p-3 mt-5' >
                <BootstrapAccordion />
                <InputGroup>
                    <InputGroup.Checkbox checked={checked} onChange={(e) => {
                        setChecked(e.target.checked)
                    }} />
                    <InputGroup.Text>Kapazität</InputGroup.Text>
                    <FormControl type='number' value={x} onChange={(e) => setX(parseInt(e.target.value))} disabled={!checked} />
                </InputGroup>
            </Form>
        </Container>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/tests/testAccordion/BootstrapAccordion.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/tests/testAccordion/BootstrapAccordion.tsx
fileSize: 658
nested []
replaced:
import AccordionItem from "react-bootstrap/AccordionItem";
import Accordion from "react-bootstrap/Accordion";

export default function BootstrapAccordion() {
    return <Accordion defaultActiveKey={'0'}>
        <Accordion.Item eventKey='0'>
            <Accordion.Header>Bootstrap Title 1</Accordion.Header>
            <Accordion.Body>
                <div>bla 1</div>
            </Accordion.Body>
        </Accordion.Item>
        <Accordion.Item eventKey='1'>
            <Accordion.Header>Bootstrap Title 2</Accordion.Header>
            <Accordion.Body>
                <div>bla 2</div>
            </Accordion.Body>
        </Accordion.Item>
    </Accordion>
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/tests/testFormComp/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/tests/testFormComp/page.tsx
fileSize: 2047
replaced:
'use client'

import Input2 from "@/app/_lib/pr-client-utils/Input2";
import FormComp from "@/app/_lib/pr-client-utils/FormComp";
import { useState } from "react";
import { myCssSupports } from "@/app/_lib/pr-client-utils/myCssSupports";

export default function Page() {
    const [width, setWidth] = useState<string>('810px');
    const [height, setHeight] = useState<string>('600px');
    const [age, setAge] = useState('0');
    const [eye, setEye] = useState('');
    const [maxWidth, setMaxWidth] = useState('800')
    const [maxHeight, setMaxHeight] = useState('600')

    function validateEye(t: string) {
        return t === 'braun' || t === 'blau' ? '' : 'Nur braun oder blau erlaubt ;-)'
    }

    return (
        <div style={{
            border: '3px solid blue',
            backgroundColor: 'inherit'
        }}>
            <Input2 type='text' label='Breite' text={width} setText={setWidth} validate={(text) => 
                 (myCssSupports('width', width)) ? '' : 'Ungültiger CSS-String!'
            } />
            <Input2 type='text' label='Höhe' text={height} setText={setHeight} validate={(text) => 
                 (myCssSupports('height', height)) ? '' : 'Ungültiger CSS-String!'
            } />
            <Input2 type='number' label='maxWidth' text={maxWidth} setText={setMaxWidth} />
            <Input2 type='number' label='maxHeight' text={maxHeight} setText={setMaxHeight} />

            <div style={{
                width: myCssSupports('width', width) ? width : 'auto',
                height: true ? 'auto' : myCssSupports('height', height) ? height : 'auto',
                border: '5px solid gold'
            }}>
                <FormComp maxWidth={Number.parseInt(maxWidth)} maxHeight={Number.parseInt(maxHeight)}>
                    <Input2 type='text' label='Augenfarbe' text={eye} setText={setEye} validate={validateEye} />
                    <Input2 type='number' label='Alter in Jahren' text={age} setText={setAge} />
                </FormComp>
            </div>
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/testWhatsapp/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/testWhatsapp/page.tsx
fileSize: 735
replaced:
'use client'

import { useState } from "react"
import Input from "../_lib/Input"
import { whatsappLink } from "../_lib/whatsapp"

export default function Page() {
    const [nr, setNr] = useState('')
    const [msg, setMsg] = useState('')
    const [url, setUrl] = useState('');
    function onSend() {
        setUrl(whatsappLink(nr, msg))
        // setUrl(`https://api.whatsapp.com/send?phone=${encodeURIComponent(nr)}&text=${encodeURIComponent(msg)}`);
    }
    return (
        <>
            <Input label='Telefonnr' text={nr} setText={setNr}/>
            <Input label='Nachricht' text={msg} setText={setMsg} />
            <button onClick={onSend}>Senden</button>
            <p><a href={url}>{url}</a></p>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/login/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/login/page.tsx
fileSize: 4699
replaced:
'use client'

import { useEffect, useRef, useState } from 'react';
import styles from './page.module.css'
import { LoginReq } from '../_lib/user-management-client/user-management-common/login';
import { userLoginFetch } from '../_lib/user-management-client/userManagementClient';
import { useRouter } from 'next/navigation';
import Header from '../_lib/Header';
import Input from '../_lib/Input';
import Menu from '../_lib/Menu';
import { login, userAndTokenFromStorages, userAndTokenToStorages } from '../_lib/userAndToken';
import FormComp from '../_lib/pr-client-utils/FormComp';
import Input2 from '../_lib/pr-client-utils/Input2';
import { LocalContext } from '../_lib/LocalContext';
import FixedAbortController from '../_lib/pr-client-utils/FixedAbortController';
import { isAbortError } from '../_lib/utils';
import Button from '../_lib/Button';

export default function Page() {
    const [user, setUser] = useState('');
    const [passwd, setPasswd] = useState('');
    const token = useRef<string | null>(null);
    const router = useRouter()
    const [comment, setComment] = useState('');
    const [d4Props, setD4Props] = useState({
        top: '',
        left: '',
        width: '',
        alpha: '',
    })
    const [cookiesAccepted, setCookiesAccepted] = useState(false);
    const abortControllerRef = useRef<AbortController | null>(null);

    useEffect(() => {
        abortControllerRef.current = new FixedAbortController();
        return () => {
            abortControllerRef.current?.abort();
        }
    }, [])

    useEffect(() => {
        if (!cookiesAccepted) return;
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) return;
        setUser(user1)
    }, [cookiesAccepted])

    function onLoginClick() {
        const req: LoginReq = {
            user: user,
            passwd: passwd
        }
        setComment('Sende Daten ...');
        login(user, passwd, abortControllerRef.current?.signal).then(resp => {
            switch (resp.type) {
                case 'error':
                    setComment(resp.error);
                    break;
                case 'success':
                    token.current = resp.token;
                    const ctx = new LocalContext();
                    if (ctx.allActivitiesAsStartPage) {
                        router.push('/group-admin/all-activities')
                    } else {
                        router.push('/group-admin');
                    }
                    break;

            }
        }).catch((reason: any) => {
            if (isAbortError(reason)) {
                // ignore
            } else {
                setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
            }
        })
    }

    useEffect(() => {
        if (typeof (window) !== 'object') return;
        const d4 = document.getElementById('d4');
        if (d4 == null) return;
        const cs = window.getComputedStyle(d4);
        const top = cs.getPropertyValue('top');
        setD4Props({
            top: top,
            left: cs.getPropertyValue('left'),
            width: cs.getPropertyValue('width'),
            alpha: cs.getPropertyValue('--alpha'),
        })
    }, [])
    // const compSt = typeof(window) === 'object' ? window.getComputedStyle(document.documentElement) : null;
    // const theta = compSt?.getPropertyValue('--theta')
    // const testTan = compSt?.getPropertyValue('--testTan');
    // const alpha = compSt?.getPropertyValue('--alpha');
    // const h1 = compSt?.getPropertyValue('--h1');
    // const w1 = compSt?.getPropertyValue('--w1');


    return (
        <>
            {/* <Header user={user} line1={{ text: 'pr-groups', fontSize: '1.2rem', bold: false }} margin='1rem' line2={{ text: 'Login', fontSize: '1.5rem', bold: true }} /> */}
            <Menu setCookiesAccepted={setCookiesAccepted} />
            <div className={styles.main}>
                <h1>pr-groups</h1>
                <FormComp decoImg={{ src: '/group-friends-jumping-top-hill.jpg', alt: 'Gruppe', width: 714, height: 576 }} maxWidth={1280} >
                    <div className={styles.innerForm}>
                        <h1>Anmelden</h1>
                        <Input2 label='User' text={user} setText={setUser} onEnter={onLoginClick} />
                        <Input2 label='Passwort' type='password' text={passwd} setText={setPasswd} onEnter={onLoginClick} />
                        <Button className={styles.loginButton} onClick={onLoginClick}>Login</Button>
                        <p className={styles.comment}>{comment}</p>

                    </div>
                </FormComp>
            </div>
        </>

    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/Popup.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/Popup.tsx
fileSize: 2793
replaced:
import { PropsWithChildren, useEffect, useRef } from "react";
import ModalDialog from "./_lib/ModalDialog";
import styles from './Popup.module.css'
import { withStopPropagation } from "./_lib/utils";

export interface PopupProps {
    round?: boolean;
    visible: boolean;
    setVisible?: (visible: boolean) => void
}

export function Popup({ round, visible, setVisible, children }: PropsWithChildren<PopupProps>) {
    const dialogRef = useRef<HTMLDialogElement>(null);

    useEffect(() => {
        if (visible) {
            dialogRef.current?.showModal()
        } else {
            dialogRef.current?.close()
        }
    }, [visible])
    return (
        <>
            {
                visible &&
                <dialog ref={dialogRef} className='dialog' onClose={() => { if (setVisible) setVisible(false) }}>
                    <div className={styles.popupOuter + (round ? ' ' + styles.round : '')}>
                        {
                            setVisible != null &&
                            <button className={styles.close} onClick={withStopPropagation(() => setVisible(false))} tabIndex={0}>
                            </button>
                        }
                        <div className={styles.popupContent + ' scrollable'}>
                            {children}
                            {/* {
                            setVisible != null &&
                            <div className={styles.popupButtonRow}>
                                <button onClick={(e) => { setVisible(false); e.stopPropagation(); }}>SCHLIEẞEN</button>
                            </div>

                        } */}
                        </div>
                    </div>
                </dialog>

                // <ModalDialog onDeactivate={() => setVisible && setVisible(false)}>
                //     <div className={styles.popupOuter}>
                //         {
                //             setVisible != null &&
                //             <button className={styles.close} onClick={withStopPropagation(() => setVisible(false))} tabIndex={0}>
                //             </button>
                //         }
                //         <div className={styles.popupContent + ' scrollable'}>
                //             {children}
                //             {/* {
                //                 setVisible != null &&
                //                 <div className={styles.popupButtonRow}>
                //                     <button onClick={(e) => { setVisible(false); e.stopPropagation(); }}>SCHLIEẞEN</button>
                //                 </div>

                //             } */}
                //         </div>
                //     </div>
                // </ModalDialog>
            }
        </>
    )

}


path: "/home/peter/my_projects/individual-gits/pr-groups/app/testLayout/1/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/testLayout/1/page.tsx
fileSize: 357
replaced:
import styles from './page.module.css'

export default function Page() {
    return (
        <div className={styles.container}>
            <div className={styles.sth}>
                Sth in the container
            </div>
            <div className={styles.bottomBar}>
                bottomBar with height 3rem
            </div>
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/group-admin/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/group-admin/page.tsx
fileSize: 6159
replaced:
'use client'

import Link from "next/link";
import Profile from "../_lib/Profile";
import useUser from "../_lib/useUser";
import styles from './page.module.css'
import Header from "../_lib/Header";
import { useCallback, useEffect, useState } from "react";
import { GroupAdminGroupsReq, GroupAdminGroupsResp } from "../_lib/api";
import { SessionContext } from "../_lib/SessionContext";
import { apiFetchPost } from "../_lib/user-management-client/apiRoutesClient";
import TabButton from "../_lib/TabButton";
import TabPage from "../_lib/TabPage";
import FixedAbortController from "../_lib/pr-client-utils/FixedAbortController";
import Menu, { CustomMenuItem } from "../_lib/Menu";
import { Popup } from "../Popup";
import LoginComp from "../_lib/user-management-client/LoginComp";
import { LocalContext } from "../_lib/LocalContext";
import { userAndTokenFromStorages } from "../_lib/userAndToken";
import useLoginLogout from "../_lib/useLoginLogout";
import FormComp from "../_lib/pr-client-utils/FormComp";

export default function Page() {
    const [comment, setComment] = useState('');
    const [groups, setGroups] = useState<string[] | null>(null);
    const [spinning, setSpinning] = useState(true);
    const [cookiesAccepted, setCookiesAccepted] = useState(false);

    const [user, onLoginClick, onLogoutClick, loginLogoutSpinning, userText, setUserText, passwdText, setPasswdText, loginError, logoutError] = useLoginLogout()


    const fetchData = useCallback(function fetchData(abortController?: AbortController) {
        const [user1, token1] = userAndTokenFromStorages();

        if (user1 == null || token1 == null) {
            setSpinning(false);
            return;
        }

        const req: GroupAdminGroupsReq = {
            user: user1,
            token: token1
        }
        setSpinning(true);
        apiFetchPost<GroupAdminGroupsReq, GroupAdminGroupsResp>('/api/group-admin/groups', req, abortController?.signal).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    onLogoutClick();
                    break;
                case 'success':
                    setGroups(resp.groupIds);
                    break;
            }
        }).catch(reason => {
            if ('name' in reason && reason.name === 'AbortError') {
                // ignore
            } else {
                setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
            }
        }).finally(() => {
            setSpinning(false);
        })

    }, [onLogoutClick])

    useEffect(() => {
        const abortController = new FixedAbortController();
        if (user != null) {
            fetchData(abortController);
        }
        return (() => {
            abortController.abort();
        })
    }, [fetchData, user])

    const customMenuItems: CustomMenuItem[] = user == null ? [] : [
        {
            type: 'normal',
            label: `${user} abmelden`,
            onClick: onLogoutClick
        }
    ]

    return (
        <>
            <Menu customSpinning={spinning} setCookiesAccepted={setCookiesAccepted} customItems={customMenuItems} >
                <Header user={null} line1={{ text: 'pr-groups', fontSize: '1.2em', bold: false }} margin='1em' line2={{ text: 'Gruppenadministration', fontSize: '1.5em', bold: true }} />
                <div className={styles.main}>

                    <FormComp decoImg={{ src: '/group-friends-jumping-top-hill.jpg', alt: 'Gruppe', width: 714, height: 576 }} maxWidth={1280} >
                        <div className={styles.form}>
                            <p>{comment}</p>
                            {/* <div className={styles.row}> */}
                            <Link className={styles.linkMemberAdd} href='/group/member/add'>Gruppenmitglied hinzufügen</Link>
                            {/* </div> */}
                            {/* <div className={styles.row}>
                    <Link className={styles.linkMemberRemove} href='/group/member/remove'>Gruppenmitglied entfernen</Link>
                </div> */}
                            {/* <div className={styles.row}> */}
                            <Link className={styles.linkActivityAdd} href='/group/activity/add'>Aktivität hinzufügen</Link>
                            {/* </div> */}
                            {/* <div className={styles.row}>
                    <Link className={styles.linkActivityDelete} href='/group/activity/delete'>Aktivität entfernen</Link>
                </div>
                <div className={styles.row}>
                    <Link className={styles.linkActivityChange} href='/group/activity/change'>Aktivität bearbeiten</Link>
                </div> */}
                            <div className={styles.groups}>
                                {
                                    groups == null ?
                                        <div className='loader'></div>
                                        :
                                        <>
                                            <h3 className={styles.groupHeader}>Du bist Administrator folgender Gruppen:</h3>
                                            {
                                                groups.map(group =>
                                                    <Link key={group} href={`/group-admin/group-m/${group}`} >{group}</Link>)
                                            }
                                        </>
                                }
                            </div>
                            <Link className={styles.linkAllActivities} href='/group-admin/all-activities'>Alle aktuellen Aktivitäten all deiner Gruppen auf einen Blick</Link>
                        </div>
                    </FormComp>
                </div>
                <Popup visible={user == null} >
                    <LoginComp user={userText} setUser={setUserText} passwd={passwdText} setPasswd={setPasswdText} onLoginClick={onLoginClick} comment={loginError} spinning={loginLogoutSpinning} />
                </Popup>
            </Menu>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/group-admin/layout.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/group-admin/layout.tsx
fileSize: 217
replaced:
export default function Layout({ children }: Readonly<{
    children: React.ReactNode;
  }>) {
    return (
        <>
            <div className='d3'>
                {children}
            </div>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/group-admin/group-2/[id]/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/group-admin/group-2/[id]/page.tsx
fileSize: 5709
replaced:
'use client'

import Header from "@/app/_lib/Header";
import Menu from "@/app/_lib/Menu";
import { useCallback, useEffect, useRef, useState } from "react";
import styles from './page.module.css'
import FormComp from "@/app/_lib/pr-client-utils/FormComp";
import Input2 from "@/app/_lib/pr-client-utils/Input2";
import { userAndTokenFromStorages } from "@/app/_lib/userAndToken";
import assert from "assert";
import { EditedActivity, GroupAdminGroupReq, GroupAdminGroupResp, ImgData, Member } from "@/app/_lib/api";
import { apiFetchPost } from "@/app/_lib/user-management-client/apiRoutesClient";
import { HeaderLine } from "@/app/_lib/HeaderLine";
import { SessionContext } from "@/app/_lib/SessionContext";
import FixedAbortController from "@/app/_lib/pr-client-utils/FixedAbortController";
import useLoginLogout from "@/app/_lib/useLoginLogout";

export default function Page({ params }: { params: { id: string } }) {
    const [spinning, setSpinning] = useState(false);
    const [groupId, setGroupId] = useState<string | null>(null);
    const abortControllerRef = useRef<AbortController | null>(null)
    const [user, onLoginClick, onLogoutClick, loginLogoutSpinning, userText, setUserText, passwdText, setPasswdText, loginError, logoutError] = useLoginLogout()
    const groupIdRef = useRef<string | null>(null);
    const [comment, setComment] = useState('');
    const [logo, setLogo] = useState<ImgData | null>(null);
    const [line1, setLine1] = useState<HeaderLine | null>(null);
    const [margin, setMargin] = useState('')
    const [line2, setLine2] = useState<HeaderLine | null>(null);
    const [docTitle, setDocTitle] = useState<string | null>(null);
    const [lastDocTitle, setLastDocTitle] = useState<string>('pr-groups');
    const [admins, setAdmins] = useState<string[]>([]);
    const [members, setMembers] = useState<Member[]>([]);
    const [activities, setActivities] = useState<EditedActivity[]>([]);
    const [activityIdxToArchive, setActivityIdxToArchive] = useState<number[]>([]);
    const [dirty, setDirty] = useState(false);

    const fetchData = useCallback(() => {
        const signal = abortControllerRef.current?.signal;
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            onLogoutClick();
            setSpinning(false);
            return;
        }
        assert(groupIdRef.current != null);
        const req: GroupAdminGroupReq = {
            user: user1,
            token: token1,
            groupId: groupIdRef.current
        }
        setSpinning(true);
        const id = Math.random();
        const abortController = abortControllerRef.current;
        if (abortController == null) throw new Error('abortController null?!');
        apiFetchPost<GroupAdminGroupReq, 
        GroupAdminGroupResp>('/api/group-admin/group/', req, signal).then(resp => {
            signal?.throwIfAborted();
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    onLogoutClick();
                    break;
                case 'success': {
                    setLogo(resp.logo)
                    setLine1(resp.line1);
                    setMargin(resp.margin);
                    setLine2(resp.line2);
                    setDocTitle(resp.docTitle);
                    setAdmins(resp.admins)
                    setMembers(resp.members)
                    setActivities(resp.activities)
                    setActivityIdxToArchive([]);
                    const ctx = new SessionContext();
                    ctx.activities = resp.activities;
                    setDirty(false)
                    setComment('Zum Bearbeiten jeweils anklicken.')
                    break;
                }
            }
        }).catch(reason => {
            if ('name' in reason && reason.name === 'AbortError') {
                // expected
            } else {
                console.error('Unexpected error', reason)
                onLogoutClick();
            }
        }).finally(() => {
            setSpinning(false);
        })

    }, [onLogoutClick])

    useEffect(() => {
        const abortController = abortControllerRef.current = new FixedAbortController();
        setGroupId(groupIdRef.current = decodeURIComponent(params.id))
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            setComment('Nicht eingeloggt.');
            return;
        }
        const id = Math.random();
        fetchData();

        return () => {
            abortController.abort()
        }
    }, [params.id, fetchData])

    return (
        <>
            <Menu customSpinning={spinning} customItems={[]} setCookiesAccepted={() => {}} >
                <Header user={null}
                line1={{
                    text: 'pr-groups / Gruppe bearbeiten',
                    fontSize: '1.2rem', 
                    bold: false
                }}
                margin='1rem'
                line2={{
                    text: groupId == null ? '' : `Gruppe ${groupId}`,
                    fontSize: '1.5rem',
                    bold: true
                }}
                 />
                <div className={styles.main}>
                    <FormComp decoImg={{ src: '/group-friends-jumping-top-hill.jpg', alt: 'Gruppe', width: 714, height: 576 }} maxWidth={1280} >
                        <div className={styles.form}>
                            <Input2 label='Gruppe' text={groupId ?? ''} setText={setGroupId} />
                        </div>
                    </FormComp>
                </div>
            </Menu>
        </>
    )
}


path: "/home/peter/my_projects/individual-gits/pr-groups/app/group-admin/group/[id]/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/group-admin/group/[id]/page.tsx
fileSize: 23125
replaced:
'use client'

import Header from "@/app/_lib/Header";
import { SessionContext } from "@/app/_lib/SessionContext";
import { Activity, GroupActivityDeleteReq, GroupActivityDeleteResp, GroupAdminActivityUpdateReq, GroupAdminActivityUpdateResp, GroupAdminAddReq, GroupAdminAddResp, GroupAdminDeleteReq, GroupAdminDeleteResp, GroupAdminGroupReq, GroupAdminGroupResp, GroupAdminMemberAddReq, GroupAdminMemberAddResp, GroupAdminMemberUpdateReq, GroupAdminMemberUpdateResp, GroupMemberAddReq, GroupMemberAddResp, Member } from "@/app/_lib/api";
import useUser from "@/app/_lib/useUser";
import { useCallback, useEffect, useRef, useState } from "react";
import styles from './page.module.css'
import { apiFetchPost } from "@/app/_lib/user-management-client/apiRoutesClient";
import TabButton from "@/app/_lib/TabButton";
import TabPage from "@/app/_lib/TabPage";
import { dateFromMillisOrNull, formatDateTime, millisFromDateOrNull } from "@/app/_lib/utils";
import Image from "next/image";
import Link from "next/link";
import { Popup } from "@/app/Popup";
import Input from "@/app/_lib/Input";
import DateTimeInput from "@/app/_lib/pr-client-utils/DateTimeInput";
import Menu, { CustomMenuItem } from "@/app/_lib/Menu";
import MemberAdd from "@/app/_lib/MemberAdd";
import { useRouter } from "next/navigation";
import { LocalContext } from "@/app/_lib/LocalContext";
import { userAndTokenFromStorages } from "@/app/_lib/userAndToken";

function invitationLink(group: string, member: Member): string {
    return `/member/${encodeURIComponent(group)}/${encodeURIComponent(member.phoneNr)}/${encodeURIComponent(member.token)}`
}

export default function Page({ params }: { params: { id: string } }) {
    const [comment, setComment] = useState('');
    const user = useUser();
    const [members, setMembers] = useState<Member[]>([]);
    const [activities, setActivities] = useState<Activity[]>([]);
    const [admins, setAdmins] = useState<string[]>([]);
    type PhoneNr = string;
    const [copied, setCopied] = useState<Member | null>(null);
    const [sel, setSel] = useState<string>('members');
    const [editedMember, setEditedMember] = useState<Member | null>(null);
    const [editedActivity, setEditedActivity] = useState<Activity | null>(null);
    const [capacityStr, setCapacityStr] = useState('');
    const [spinning, setSpinning] = useState(true);
    const groupIdRef = useRef<string | null>(null);
    const [groupId, setGroupId] = useState<string | null>(null);
    const [addingMember, setAddingMember] = useState(false);
    const [cookiesAccepted, setCookiesAccepted] = useState(false);
    const router = useRouter();

    useEffect(() => {
        if (!cookiesAccepted) return;
        setGroupId(groupIdRef.current = decodeURIComponent(params.id))
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            setComment('Nicht eingeloggt.');
            return;
        }
        const req: GroupAdminGroupReq = {
            user: user1,
            token: token1,
            groupId: groupIdRef.current
        }
        setSpinning(true);
        apiFetchPost<GroupAdminGroupReq, GroupAdminGroupResp>('/api/group-admin/group/', req).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    break;
                case 'success':
                    setMembers(resp.members)
                    setActivities(resp.activities)
                    setAdmins(resp.admins)
                    break;
            }
        }).finally(() => {
            setSpinning(false);
        })
    }, [params.id, cookiesAccepted])

    const onCopyClick = (member: Member) => () => {
        if (groupIdRef.current == null) return;
        setCopied(null);
        navigator.clipboard.writeText(location.origin + invitationLink(groupIdRef.current, member)).then(() => {
            setCopied(member);
        })
    }

    const onMemberEditClick = (phoneNr: string) => () => {
        const m = members.find((m) => m.phoneNr === phoneNr);
        setEditedMember(m ?? null);
    }

    function activityFromCreationDate(creationDate: number) {
        const activity = activities.find(a => a.creationDate === creationDate)
        if (activity == null) {
            throw new Error('No activity with creationDate: ' + creationDate);
        }
        return activity;
    }

    const onActivityDeleteClick = (creationDate: number) => () => {
        const activity = activityFromCreationDate(creationDate);
        if (!confirm(`Aktivität ${activity.name} am ${formatDateTime(dateFromMillisOrNull(activity.date))} wirklich löschen?`)) return;
        const [user1, token1] = userAndTokenFromStorages();

        if (user1 == null || token1 == null || groupIdRef.current == null) return;
        const req: GroupActivityDeleteReq = {
            user: user1,
            token: token1,
            group: groupIdRef.current,
            activityCreationDate: creationDate
        }
        setSpinning(true);
        apiFetchPost<GroupActivityDeleteReq, GroupActivityDeleteResp>('/api/group-admin/activity-delete', req).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert');
                    break;
                case 'success':
                    setActivities(resp.activities);
                    break;
                case 'groupNotFound':
                    setComment('Gruppe nicht gefunden');
                    break;
                case 'error':
                    setComment('Unerwarteter Fehler: ' + resp.error)
                    break;
            }
        }).finally(() => {
            setSpinning(false);
        })
    }

    const onActivityEditClick = (creationDate: number) => () => {
        const activity = activityFromCreationDate(creationDate);
        setEditedActivity({
            ...activity,
        })
        setCapacityStr(activity.capacity?.toString() ?? '')
    }

    function saveEditedMember() {
        if (editedMember == null) return;
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null || groupIdRef.current == null) {
            setComment('Nicht eingeloggt.');
            return;
        }
        const req: GroupAdminMemberUpdateReq = {
            user: user1,
            token: token1,
            groupId: groupIdRef.current,
            member: editedMember
        }
        setSpinning(true);
        apiFetchPost<GroupAdminMemberUpdateReq, GroupAdminMemberUpdateResp>('/api/group-admin/member-update', req).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    break;
                case 'notFound':
                    setComment('Nicht gefunden');
                    break;
                case 'success':
                    setEditedMember(null);
                    setMembers(resp.members);
                    break;
                case 'error':
                    setComment('Unerwarteter Fehler: ' + resp.error);
                    break;
            }
        }).catch(reason => {
            setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
        }).finally(() => {
            setSpinning(false);
        })
    }

    function saveEditedActivity() {
        if (editedActivity == null) return;
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null || groupIdRef.current == null) {
            setComment('Nicht eingeloggt.');
            return;
        }
        const a = editedActivity;
        const parsedCapacity = parseInt(capacityStr);
        if (!confirm(`Wirklich speichern?\n` +
            `Name: ${a.name}\n` +
            `Datum/Uhrzeit: ${formatDateTime(a.date, true)}\n` +
            `Kapazität: ${parsedCapacity}`)) return;
        const req: GroupAdminActivityUpdateReq = {
            user: user1,
            token: token1,
            groupId: groupIdRef.current,
            creationDate: a.creationDate,
            activityData: {
                name: a.name,
                date: a.date,
                capacity: parsedCapacity
            }
        }
        setSpinning(true);
        apiFetchPost<GroupAdminActivityUpdateReq, GroupAdminActivityUpdateResp>('/api/group-admin/activity-update', req).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    break;
                case 'notFound':
                    setComment('Nicht gefunden.');
                    break;
                case 'error':
                    setComment('Unerwarteter Fehler: ' + resp.error);
                    break;
                case 'success':
                    setActivities(resp.activities);
                    setEditedActivity(null);
                    break;
            }
        }).catch(reason => {
            setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
        }).finally(() => {
            setSpinning(false);
        })
    }

    const setDate = useCallback((d: Date | null) => {
        setEditedActivity((ed) => {
            if (ed == null) return null;
            const newDate = millisFromDateOrNull(d);
            return {
                ...ed,
                date: newDate
            }
        })
    }, [])

    const onAdminDeleteClick = (admin: string) => () => {
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null || groupIdRef.current == null) {
            setComment('Nicht eingeloggt.');
            return;
        }
        const sentGroup = groupIdRef.current;
        const req: GroupAdminDeleteReq = {
            user: user1,
            token: token1,
            group: sentGroup,
            groupAdminUser: admin,
            getList: true
        }
        setSpinning(true);
        apiFetchPost<GroupAdminDeleteReq, GroupAdminDeleteResp>('/api/group/admin/delete', req).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    break;
                case 'success':
                    setComment(`${admin} ist nun nicht mehr Gruppen-Admin von ${groupIdRef.current}`)
                    if (resp.admins != null) setAdmins(resp.admins)
                    break;
                case 'groupNotFound':
                    setComment(`Gruppe ${sentGroup} existiert nicht.`);
                    break;
                case 'wasNotGroupAdmin':
                    setComment(`${admin} war kein Gruppen-Admin von ${sentGroup}.`)
                    break;
                case 'error':
                    setComment('Unerwarteter Fehler: ' + resp.error);
                    break;
            }
        }).catch(reason => {
            console.error(reason);
            setComment('Unerwarteter Fehler: ' + JSON.stringify(reason))
        }).finally(() => {
            setSpinning(false);
        })
    }

    function onAdminAddClick() {
        const newAdmin = prompt(`Which user do you like to add as a new group admin for ${groupIdRef.current}?`);
        if (newAdmin == null) return;
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null || groupIdRef.current == null) {
            setComment('Nicht eingeloggt.');
            return;
        }
        const sentGroup = groupIdRef.current;
        const req: GroupAdminAddReq = {
            user: user1,
            token: token1,
            group: sentGroup,
            groupAdminUser: newAdmin,
            getList: true
        }
        setSpinning(true);
        apiFetchPost<GroupAdminAddReq, GroupAdminAddResp>('/api/group/admin/add', req).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    break;
                case 'groupNotFound':
                    setComment(`Gruppe ${sentGroup} existiert nicht.`);
                    break;
                case 'success':
                    if (resp.admins != null) {
                        setAdmins(resp.admins)
                    }
                    setComment(`${newAdmin} ist nun Gruppen-Admin von ${sentGroup}.`)
                    break;
                case 'userNotFound':
                    setComment(`${newAdmin} ist kein bekannter User.`);
                    break;
                case 'wasGroupAdmin':
                    setComment(`${newAdmin} war bereits Gruppen-Admin von ${sentGroup}.`);
                    break;
                case 'error':
                    setComment('Unerwarteter Fehler: ' + resp.error);
                    break;
            }
        }).catch(reason => {
            setComment('Unerwarteter Fehler: ' + JSON.stringify(reason))
        }).finally(() => {
            setSpinning(false);
        })
    }

    function onAddMember() {
        setAddingMember(true);
    }

    async function onMemberAdded({ group, newPhoneNr, prename, surname }: { group: string; newPhoneNr: string; prename: string; surname: string }) {
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            setComment('Du bist nicht eingeloggt.')
            return;
        }
        const req: GroupAdminMemberAddReq = {
            user: user1,
            token: token1,
            groupId: group,
            phoneNr: newPhoneNr,
            prename: prename,
            surname: surname,
        }
        setComment('Sende Daten ...');
        setAddingMember(false);
        setSpinning(true);
        try {
            const resp = await apiFetchPost<GroupAdminMemberAddReq, GroupAdminMemberAddResp>('/api/group-admin/member-add', req)
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    break;
                case 'success':
                    setMembers(resp.members)
                    break;
                case 'groupNotFound':
                    setComment(`Gruppe ${group} existiert nicht.`);
                    break;
                case 'phoneNrContained':
                    setComment(`Abgebrochen. Es gibt bereits ein Mitglied mit Telefonnr ${newPhoneNr} in Gruppe ${group}.`)
                    break;
                case 'error':
                    setComment(`Unerwarteter Fehler: ${resp.error}`);
                    break;
            }
        } finally {
            setSpinning(false);
        }
    }

    const customMenuItems: CustomMenuItem[] = [
        {
            label: 'LAYOUT FÜR HANDY',
            onClick: () => router.push(`/group-admin/group-m/${params.id}`)
        }
    ]

    return (
        <Menu onDeleteMemberClick={null} group={null}
            customItems={customMenuItems}
            setCookiesAccepted={setCookiesAccepted}>
            <Header
                user={user}
                line1={{ text: 'pr-groups / Gruppenadmin', fontSize: '1.2rem', bold: false }}
                margin='1rem'
                line2={{ text: groupId ?? '', fontSize: '1.5rem', bold: true }}
            />
            <div className={styles.main}>
                <div className={styles.buttonRow}>
                    <TabButton label="Mitglieder" ownKey='members' selectedKey={sel} setSelectedKey={setSel} />
                    <TabButton label="Aktivitäten" ownKey='activities' selectedKey={sel} setSelectedKey={setSel} />
                    <TabButton label="Gruppen-Admins" ownKey='admins' selectedKey={sel} setSelectedKey={setSel} />
                </div>
                <div className={styles.selPage}>
                    <TabPage ownKey="members" selectedKey={sel}>
                        <p>{comment}</p>
                        <div className={`${styles.clickable} ${styles.buttonRow}`} onClick={onAddMember}><Image alt='Mitglied hinzufügen' src='/square_14034302.png' width={32} height={32} /><div className={styles.imgLabel}>Mitglied hinzufügen</div></div>
                        <table border={1} cellPadding={3}>
                            <tbody>
                                <tr>
                                    <th>phoneNr</th><th>Name</th><th>Einladungslink</th><th>Link kopieren</th><th>Bearbeiten</th>
                                </tr>
                                {
                                    members.map(member =>
                                        <tr key={member.phoneNr}>
                                            <td>
                                                {member.phoneNr}
                                            </td>
                                            <td>
                                                {member.prename} {member.surname}
                                            </td>
                                            <td>
                                                <a href={location.origin + invitationLink((groupId ?? '<FEHLER>'), member)}>{location.origin + invitationLink(groupId ?? '<FEHLER>', member)}</a>
                                            </td>
                                            <td><button className={`${styles.copy} ${copied?.phoneNr === member.phoneNr && styles.copied}`} onClick={onCopyClick(member)} /></td>
                                            <td onClick={onMemberEditClick(member.phoneNr)} className={styles.clickable}><Image src='/edit_12000664.png' alt='Bearbeiten' width={32} height={32} /></td>

                                        </tr>
                                    )
                                }

                            </tbody>
                        </table>
                    </TabPage>
                    <TabPage ownKey='activities' selectedKey={sel}>
                        <p>{comment}</p>
                        <table border={1} cellPadding={3}>
                            <tbody>
                                <tr>
                                    <th>Was</th><th>Wann</th><th>Kapazität</th><th>Erstellt</th><th>Löschen</th><th>Bearbeiten</th>
                                </tr>
                                {
                                    activities.map((a) =>
                                    (<tr key={a.creationDate}>
                                        <td>{a.name}</td>
                                        <td>{formatDateTime(a.date, true)}</td>
                                        <td className={styles.capacity}>{a.capacity}</td>
                                        <td>{formatDateTime(a.creationDate, true)}</td>
                                        <td onClick={onActivityDeleteClick(a.creationDate)} className={styles.clickable}><Image src='/cross_8995303.png' alt='Löschen' width={32} height={32} /></td>
                                        <td onClick={onActivityEditClick(a.creationDate)} className={styles.clickable}><Image src='/edit_12000664.png' alt='Bearbeiten' width={32} height={32} /></td>
                                    </tr>)
                                    )
                                }
                            </tbody>
                        </table>
                    </TabPage>
                    <TabPage ownKey='admins' selectedKey={sel}>
                        <p>{comment}</p>
                        <table border={1} cellPadding={3}>
                            <tbody>
                                <tr>
                                    <th>User</th><th>Hinzufügen/Entfernen</th>
                                </tr>
                                <tr>
                                    <td className={styles.add}>(Neuer Gruppen-Admin)</td><td onClick={onAdminAddClick} className={styles.clickable}><Image src='/square_14034302.png' alt='Gruppen-Admin hinzufügen' width={32} height={32} /></td>
                                </tr>
                                {
                                    admins.map((admin) =>
                                        <tr key={admin}>
                                            <td>{admin}</td>
                                            <td onClick={onAdminDeleteClick(admin)} className={styles.clickable}><Image src='/cross_8995303.png' alt='Löschen' width={32} height={32} /></td>
                                        </tr>
                                    )
                                }
                            </tbody>
                        </table>
                    </TabPage>
                </div>
            </div>
            <Popup visible={editedMember != null} >
                <h3>{editedMember?.phoneNr} bearbeiten</h3>
                <Input label='Vorname' text={editedMember?.prename ?? ''} setText={t => {
                    if (editedMember != null) setEditedMember({
                        ...editedMember,
                        prename: t
                    })
                }} />
                <Input label='Nachname' text={editedMember?.surname ?? ''} setText={t => {
                    if (editedMember != null) setEditedMember({
                        ...editedMember,
                        surname: t
                    })
                }} />

                <div className={styles.buttonRow}>
                    <button onClick={saveEditedMember}>SPEICHERN</button>
                    <button onClick={() => { setEditedMember(null) }}>ABBRECHEN</button>
                </div>
            </Popup>
            <Popup visible={editedActivity != null} >
                <h3>Aktivität erstellt am ({formatDateTime(dateFromMillisOrNull(editedActivity?.creationDate ?? null))}) bearbeiten</h3>
                <Input label='Name' text={editedActivity?.name ?? ''} setText={t => {
                    if (editedActivity != null) setEditedActivity({
                        ...editedActivity,
                        name: t
                    })
                }} />
                {/* date, capacity */}
                <DateTimeInput initialText={editedActivity?.date == null ? '' : formatDateTime(new Date(editedActivity?.date))} setDate={setDate} />
                <Input label='Kapazität' text={capacityStr} setText={setCapacityStr} />
                <div className={styles.buttonRow}>
                    <button onClick={saveEditedActivity}>SPEICHERN</button>
                    <button onClick={() => { setEditedActivity(null) }}>ABBRECHEN</button>
                </div>
            </Popup>
            {groupId != null &&
                <Popup visible={addingMember} >
                    <MemberAdd initialGroup={groupId} onAdd={onMemberAdded} onCancel={() => { setAddingMember(false) }} />
                </Popup>
            }
            {
                spinning &&
                <div className={'loader'}></div>
            }

        </Menu>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/group-admin/group-m/[id]/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/group-admin/group-m/[id]/page.tsx
fileSize: 48312
replaced:
'use client'

import Header from "@/app/_lib/Header";
import Menu, { CustomMenuItem } from "@/app/_lib/Menu";
import { SessionContext } from "@/app/_lib/SessionContext";
import { Activity, EditedActivity, GroupAdminGroupReq, GroupAdminGroupResp, GroupAdminGroupUpdateReq, GroupAdminGroupUpdateResp, GroupAdminMemberAddReq, GroupAdminMemberAddResp, GroupAdminMemberDeleteReq, GroupAdminMemberDeleteResp, GroupAdminMemberUpdateReq, GroupAdminMemberUpdateResp, ImgData, Member } from "@/app/_lib/api";
import useUser from "@/app/_lib/useUser";
import { apiFetchPost } from "@/app/_lib/user-management-client/apiRoutesClient";
import { ChangeEvent, FocusEventHandler, KeyboardEvent, PropsWithChildren, useCallback, useEffect, useLayoutEffect, useRef, useState } from "react";
import styles from './page.module.css'
import { type HeaderLine } from "@/app/_lib/HeaderLine";
import { dateFromMillisOrNull, formatDateTime, millisFromDateOrNull, parseGermanDate, withStopPropagation } from "@/app/_lib/utils";
import Input from "@/app/_lib/Input";
import { Popup } from "@/app/Popup";
import LoginComp from "@/app/_lib/user-management-client/LoginComp";
import assert from "assert";
import FixedAbortController from "@/app/_lib/pr-client-utils/FixedAbortController";
import Image from "next/image";
import ScrollableContainer from "@/app/_lib/pr-client-utils/ScrollableContainer";
import { ScrollableContainerProps } from "@/app/_lib/pr-client-utils/ScrollableContainerProps";
import { whatsappLink } from "@/app/_lib/whatsapp";
import MemberAdd from "@/app/_lib/MemberAdd";
import { useRouter } from "next/navigation";
import DateTimeInput from "@/app/_lib/pr-client-utils/DateTimeInput";
import Checkbox from "@/app/_lib/Checkbox";
import Label from "@/app/_lib/Label";
import EditableOptionalDateTimeComp from "@/app/_lib/pr-client-utils/EditableOptionalDateTimeComp";
import useEditableOptionalDateTime from "@/app/_lib/pr-client-utils/useEditableOptionalDateTime";
import { userAndTokenFromStorages } from "@/app/_lib/userAndToken";
import { Editable } from "@/app/_lib/clientUtils";
import { myCssSupports } from "@/app/_lib/pr-client-utils/myCssSupports";
import { LogoutReq } from "@/app/_lib/user-management-client/user-management-common/logout";
import { userLogoutFetch } from "@/app/_lib/user-management-client/userManagementClient";
import useLoginLogout from "@/app/_lib/useLoginLogout";
import Toggler1 from "@/app/_lib/pr-client-utils/Toggler1";

const MAX_GROUP_LENGTH = 20
const MAX_HEADER_LEN = 20
const MAX_DOC_TITLE_LENGTH = 20

function invitationLink(group: string, member: Member): string {
    return `/member/${encodeURIComponent(group)}/${encodeURIComponent(member.phoneNr)}/${encodeURIComponent(member.token)}`
}

function Content({ children }: PropsWithChildren<{}>) {
    return <div className={styles.content}>{children}</div>
}

interface OptionalEditableProps<T> {
    label: string;
    value: T | null;
    defaultValue: T;
    setValue: (t: T | null) => void;
    format: (t: T) => string
    /**
     * 
     * @param s text to be parsed and checked
     * @returns object of type T or raises an error string that is shown in the editor
     */
    parse: (s: string) => Promise<T>
}

function OptionalEditable<T>({ label, value, defaultValue, setValue, format, parse }: OptionalEditableProps<T>) {
    const lastValueRef = useRef<T | null>(null);
    const [text, setText] = useState('');
    const [editing, setEditing] = useState(false);

    const updateEnabled = useCallback((enabled: boolean) => {
        if (enabled) {
            const last = lastValueRef.current;
            setValue(last == null ? defaultValue : last)
        } else {
            setValue(null);
        }
    }, [defaultValue, setValue])
    return <div className={styles.optionalEditable}>
        <Checkbox
            label={label}
            checked={value != null}
            setChecked={updateEnabled}
        />
        {
            value != null &&
            <Editable value={value} setValue={setValue} format={format} parse={parse} />
        }
    </div>
}

interface EditableImgProps {
    label: string;
    img: ImgData | null;
    setImg: (img: ImgData | null) => void

}
function EditableImg({ label, img, setImg }: EditableImgProps) {
    const [imgUsed, setImgUsed] = useState(img != null);
    const [imgVal, setImgVal] = useState<ImgData>({
        src: '/',
        alt: label,
        width: 50,
        height: 50
    })
    const [editing, setEditing] = useState(false)


    useEffect(() => {
        setImgUsed(img != null);
    }, [img])

    function onImgClick() {
        setEditing(!editing);
    }

    function onFileChange(e: ChangeEvent<HTMLInputElement>) {
        if (e.target.files != null && e.target.files.length === 1) {
            if (img == null) throw new Error('img null');
            setImg({
                ...img,
                src: URL.createObjectURL(e.target.files[0])
            })
            setEditing(false)
        }
    }

    return (
        <>
            <Checkbox className={styles.checkbox} label={label} checked={imgUsed} setChecked={(b) => {
                if (!b) {
                    if (img == null) {
                        console.error('unexpected: img null')
                    } else {
                        setImgVal(img);
                        setImg(null);
                    }
                } else {
                    setImg(imgVal)
                }
                setImgUsed(b)
            }} />

            {editing && img != null && <fieldset className={styles.fieldSet}>
                <legend>{label}</legend>
                {<div><Image tabIndex={0} role="button" onKeyUp={(e: KeyboardEvent<HTMLDivElement>) => {
                    e.stopPropagation()
                    let f = () => { }
                    switch (e.key) {
                        case 'Enter': case ' ':
                            onImgClick();
                            break;
                    }
                }} onClick={onImgClick} src={img.src} alt={img.alt} width={img.width} height={img.height} /></div>}
                <Editable label='src' value={img.src} setValue={(src) => {
                    if (img != null && src != null) {
                        setImg({
                            ...img,
                            src: src
                        })
                    }
                }} format={id<string>} parse={(s) => (s === '' ? Promise.reject('Leere URL nicht möglich') : Promise.resolve(s))} />
                <input type='file' accept='image/*' onChange={(e) => onFileChange(e)} />
                <Editable label='alt' value={img.alt} setValue={(alt) => {
                    if (img != null) {
                        setImg({
                            ...img,
                            alt: alt
                        })

                    }
                }} format={id<string>} parse={(s) => (s === '' ? Promise.reject('Bitte etwas eingeben!') : Promise.resolve(s))} />
                <Editable label='width (Pixel)' value={img.width} setValue={(width) => {
                    if (img != null) {
                        setImg({
                            ...img,
                            width: width
                        })
                    }
                }} format={(width) => width.toString()} parse={(s) => {
                    if (s === '') {
                        return Promise.reject('Bitte Zahl eingeben!')
                    }
                    try {
                        const i = parseInt(s)
                        if (isFinite(i)) {
                            return Promise.resolve(i)
                        } else {
                            return Promise.reject('Bitte Zahl eingeben!')
                        }
                    } catch (reason) {
                        return Promise.reject('Bitte Zahl eingeben!')
                    }
                }} />
                <Editable label='height (Pixel)' value={img.height} setValue={(height) => {
                    if (img != null) {
                        setImg({
                            ...img,
                            height: height
                        })
                    }
                }} format={(height) => height.toString()} parse={(s) => {
                    if (s === '') {
                        return Promise.reject('Bitte Zahl eingeben!')
                    }
                    try {
                        const i = parseInt(s)
                        if (isFinite(i)) {
                            return Promise.resolve(i)
                        } else {
                            return Promise.reject('Bitte Zahl eingeben!')
                        }
                    } catch (reason) {
                        return Promise.reject('Bitte Zahl eingeben!')
                    }

                }} />
            </fieldset>}
            {!editing && img != null && <div><Image tabIndex={0} role="button" onKeyUp={(e: KeyboardEvent<HTMLDivElement>) => {
                e.stopPropagation()
                let f = () => { }
                switch (e.key) {
                    case 'Enter': case ' ':
                        onImgClick();
                        break;
                }
            }} onClick={onImgClick} src={img.src} alt={img.alt} width={img.width} height={img.height} /></div>}



        </>
    )
}

// interface EditableDateTimeProps {
//     disabled?: boolean
//     label?: string
//     info?: string
//     msValue: number
//     setValue: (ms: number) => void
// }

// function EditableDateTime({ disabled, label, info, msValue, setValue }: EditableDateTimeProps) {
//     const [editing, setEditing] = useState(false)
//     const [validation, setValidation] = useState<Validation>('valid');
//     const [error, setError] = useState<string>('')
//     const [editedDate, setEditedDate] = useState<Date | null>(null);
//     const inputRef = useRef<HTMLInputElement>(null)
//     const divRef = useRef<HTMLDivElement>(null)
//     const dialogRef = useRef<HTMLDialogElement>(null)
//     const wasEditingRef = useRef<boolean>(false)
//     const [infoVisible, setInfoVisible] = useState(false)


//     function onEditClick() {
//         console.log('onEditClick: disabled', disabled)
//         if (disabled) return;
//         console.log('onEditClick')
//         setEditing(true);
//         if (dialogRef.current != null) {
//             dialogRef.current.showModal()
//         }
//         setEditedDate(dateFromMillisOrNull(msValue))
//         // setEditedText(format(value))
//     }

//     // function onChange(s: string) {
//     //     setEditedText(s);
//     //     setValidation('validating');
//     //     setError('');
//     //     parse(s).then(value => {
//     //         setValidation('valid');
//     //     }).catch((s: any) => {
//     //         setValidation('invalid')
//     //         if (typeof s === 'string') {
//     //             console.log('setError', s)
//     //             setError(s);
//     //         } else {
//     //             console.error(s);
//     //         }
//     //     })
//     // }

//     function onCancel() {
//         setEditing(false);
//         if (dialogRef.current != null) {
//             dialogRef.current.close();
//         }
//         setValidation('valid');
//         setError('')
//     }

//     function onOk() {
//         if (editedDate == null) {
//             setValidation('invalid')
//             setError('Ungültige Eingabe!');
//         } else {
//             setValue(millisFromDateOrNull(editedDate) ?? 0)
//             setEditing(false)
//             if (dialogRef.current != null) {
//                 dialogRef.current.close();
//             }
//         }
//         // parse(editedText).then(val => {
//         //     setValue(val)
//         //     setEditing(false);
//         // }).catch((s: any) => {
//         //     setValidation('invalid')
//         //     if (typeof s === 'string') {
//         //         console.log('setError', s)
//         //         setError(s);
//         //     } else {
//         //         console.error(s);
//         //     }
//         // })

//     }

//     useEffect(() => {
//         console.log('editing', editing, 'inputRef.current', inputRef.current, 'divRef.current', divRef.current)
//         if (editing && inputRef.current != null) {
//             inputRef.current.focus();
//             wasEditingRef.current = true;
//             inputRef.current.scrollIntoView()
//         } else if (wasEditingRef.current && !editing && divRef.current != null) {
//             console.log('calling divRef.current.focus()')
//             divRef.current.focus();
//             wasEditingRef.current = false;
//         }
//     }, [editing])



//     return (
//         <>
//             <div className={styles.labelAndInfo}>
//                 {label != null && <Label>{label}</Label>}
//                 {
//                     info != null &&
//                     <>
//                         <button className={styles.infoButton}
//                             onClick={() => setInfoVisible(true)}>
//                             <Image src='/information-point_72168.png' width={32} height={32} alt='Info' />
//                         </button>
//                         <Popup visible={infoVisible} setVisible={setInfoVisible}>
//                             <p className={styles.info}>{info}</p>
//                         </Popup>
//                     </>
//                 }
//             </div>

//             <dialog ref={dialogRef} className='dialog'>
//                 <Label>{label}</Label>
//                 <DateTimeInput ref={inputRef} initialText={formatDateTime(msValue)} setDate={setEditedDate} />
//                 {
//                     error !== '' &&
//                     <p className={styles.error}>{error}</p>
//                 }
//                 <div className={styles.buttonRow}>
//                     {validation === 'valid' &&
//                         <button className={styles.okImg} onClick={withStopPropagation(onOk)}></button>}
//                     <button className={styles.cancelImg} onClick={withStopPropagation(onCancel)}></button>
//                 </div>
//             </dialog>
//             {
//                 !editing &&
//                 <div className={`${styles.content} scrollableHor`} role='button' tabIndex={0} ref={divRef} onKeyDown={(e: KeyboardEvent<HTMLDivElement>) => {
//                     e.stopPropagation()
//                     let f = () => { }
//                     switch (e.key) {
//                         case 'Enter': case ' ':
//                             onEditClick();
//                             break;
//                     }
//                 }} onClick={disabled ? undefined : withStopPropagation(onEditClick)}>{formatDateTime(msValue)}</div>
//             }
//         </>
//     )
// }

function HeaderLine({ children, label, line, setLine }: PropsWithChildren<{ label: string; line: HeaderLine; setLine: (line: HeaderLine) => void }>) {
    // const [lineUsed, setLineUsed] = useState(false);
    const [lineVal, setLineVal] = useState<HeaderLine>({
        text: '"' + label + '"',
        fontSize: '1rem',
        bold: false
    })

    // useEffect(() => {
    //     setLineUsed(line != null);
    // }, [line])

    const lineUsed = (line != null && line.text !== '')

    return (
        <>
            <Checkbox label={`${label} anzeigen`} checked={lineUsed} setChecked={(b) => {
                if (!b) {
                    if (line.text === '') {
                        console.error('unexpected: empty line text');
                    } else {
                        setLineVal(line)
                        setLine({
                            ...line,
                            text: '',
                        })
                    }
                } else {
                    setLine(lineVal)
                }
                // setLineUsed(b)
            }} />
            {lineUsed &&
                <fieldset className={styles.fieldSet}>
                    <legend>{label}</legend>
                    {
                        // line != null &&
                        <>
                            <Editable
                                label={`${label} / Text`}
                                value={line.text}
                                setValue={(text) => {
                                    setLine({
                                        ...line,
                                        text: text
                                    })
                                }}
                                format={id}
                                parse={text => { if (text === '') { return Promise.reject('darf nicht leer sein!') } else if (text.length > MAX_HEADER_LEN) { return Promise.reject(`Max. ${MAX_HEADER_LEN} Zeichen!`) } { return Promise.resolve(text) } }}
                            />
                            <Editable
                                label={`${label} / font-size`}
                                value={line.fontSize}
                                setValue={(v) => {
                                    setLine({
                                        ...line,
                                        fontSize: v
                                    })
                                }}
                                format={id}
                                parse={text => {
                                    if (myCssSupports('font-size', text)) {
                                        return Promise.resolve(text)
                                    } else {
                                        return Promise.reject('Kein gültiger CSS-Wert für font-size');
                                    }
                                }}
                            />


                            <Checkbox label='bold' checked={line.bold} setChecked={(bold) => {
                                setLine({
                                    ...line,
                                    bold: bold
                                })
                            }} />
                        </>

                    }
                </fieldset>
            }
        </>
    )
}

function id<T>(t: T) {
    return t
}

interface ActivityCompProps {
    i: number;
    a: EditedActivity;
    updateName: (name: string) => void;
    updateDate: (ms: number | null) => void;
    updateCapacity: (capacity: number | null) => void;
    onDelete: () => void;
    onArchive: () => void;
}
function ActivityComp({ i, a, updateName, updateDate, updateCapacity, onDelete, onArchive }: ActivityCompProps) {
    const [menuVisible, setMenuVisible] = useState(false)
    const [testDate, setTestDate] = useState<string>('2024-06-25T18:00');

    const [
        date_enabled,
        date_setEnabled,
        date_editedText,
        date_setEditedText,
        date_editing,
        date_setEditing,
        date_onOk,
        date_onCancel,
        date_unclearMESZ,
        date_userMESZ,
        date_setUserMESZ,
        date_error

    ] = useEditableOptionalDateTime({
        optionalMs: a.date,
        setOptionalMs: updateDate
    })

    const andCloseMenu = (f: () => void) => () => {
        setMenuVisible(false);
        f();
    }

    return <div key={i} className={styles.activity}>
        <div tabIndex={0} className={styles.menuDiv} onClick={() => setMenuVisible(true)}><Image src='/main-menu.svg' width={32 * 0.65} height={32 * 0.65} alt='Menu' /></div>
        <Popup visible={menuVisible} setVisible={setMenuVisible}>
            <p>{a.name}</p>
            <p>{formatDateTime(a.date)}</p>
            <button className={styles.delete + ' ' + styles.marginTop} onClick={andCloseMenu(onDelete)}>LÖSCHEN</button>
            <button className={styles.archive + ' ' + styles.marginTop} onClick={andCloseMenu(onArchive)}>ARCHIVIEREN</button>

        </Popup>
        <Editable label='Was'
            value={a.name}
            setValue={updateName}
            format={(name) => {
                return name
            }} parse={(s) => (
                Promise.resolve(s)
            )} />
        <EditableOptionalDateTimeComp
            label='Wann'
            enabled={date_enabled}
            setEnabled={date_setEnabled}
            editedText={date_editedText}
            setEditedText={date_setEditedText}
            editing={date_editing}
            setEditing={date_setEditing}
            onOk={date_onOk}
            onCancel={date_onCancel}
            unclearMESZ={date_unclearMESZ}
            userMESZ={date_userMESZ}
            setUserMESZ={date_setUserMESZ}
            error={date_error}
            optionalMs={a.date}
        />
        <OptionalEditable label='Kapazität'
            value={a.capacity}
            setValue={updateCapacity}
            defaultValue={2}
            format={(capacity) => capacity?.toString() ?? 'null'}
            parse={(s) => {
                const v = parseInt(s);
                if (Number.isInteger(v) && v > 0) {
                    return Promise.resolve(parseInt(s))
                } else {
                    return Promise.reject('Bitte positive ganze Zahl eingeben')
                }
            }}
        />
        <hr className={styles.hr} />
    </div>
}

export default function Page({ params }: { params: { id: string } }) {
    const groupIdRef = useRef<string | null>(null);
    const [groupId, setGroupId] = useState<string | null>(null);
    const [spinning, setSpinning] = useState(true);
    const [comment, setComment] = useState('');
    const [memberComment, setMemberComment] = useState('')
    const [logo, setLogo] = useState<ImgData | null>(null);
    const [line1, setLine1] = useState<HeaderLine | null>(null);
    const [margin, setMargin] = useState('')
    const [line2, setLine2] = useState<HeaderLine | null>(null);
    const [docTitle, setDocTitle] = useState<string | null>(null);
    const [lastDocTitle, setLastDocTitle] = useState<string>('pr-groups');
    const [admins, setAdmins] = useState<string[]>([]);
    const [members, setMembers] = useState<Member[]>([]);
    const [activities, setActivities] = useState<EditedActivity[]>([]);
    const [activityIdxToArchive, setActivityIdxToArchive] = useState<number[]>([]);
    const [dirty, setDirty] = useState(false);
    const abortControllerRef = useRef<AbortController | null>(null)
    // const [snapWidth, setSnapWidth] = useState<number>(260)
    const scrollableContainerRef = useRef<React.JSX.Element>(null)
    const [horPage, setHorPage] = useState(0)
    const [addingMember, setAddingMember] = useState(false);
    const router = useRouter();
    const [editedMemberIdx, setEditedMemberIdx] = useState<number | null>(null);
    const [editedMember, setEditedMember] = useState<Member | null>(null);
    const activityScrollableRef = useRef<HTMLDivElement>(null);
    const mainRef = useRef<HTMLDivElement>(null);
    const [cookiesAccepted, setCookiesAccepted] = useState(false);

    const [user, onLoginClick, onLogoutClick, loginLogoutSpinning, userText, setUserText, passwdText, setPasswdText, loginError, logoutError] = useLoginLogout()


    // useEffect(() => {
    //     if (mainRef.current != null) {
    //         const newSnapWidth = mainRef.current.offsetWidth;
    //         console.log('newSnapWidth', newSnapWidth);
    //         setSnapWidth(newSnapWidth)
    //     }
    // }, [])

    const fetchData = useCallback(() => {
        const signal = abortControllerRef.current?.signal;
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            onLogoutClick();
            setSpinning(false);
            return;
        }
        assert(groupIdRef.current != null);
        const req: GroupAdminGroupReq = {
            user: user1,
            token: token1,
            groupId: groupIdRef.current
        }
        setSpinning(true);
        const id = Math.random();
        const abortController = abortControllerRef.current;
        if (abortController == null) throw new Error('abortController null?!');
        apiFetchPost<GroupAdminGroupReq, GroupAdminGroupResp>('/api/group-admin/group/', req, signal).then(resp => {
            signal?.throwIfAborted();
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    onLogoutClick();
                    break;
                case 'success': {
                    setLogo(resp.logo)
                    setLine1(resp.line1);
                    setMargin(resp.margin);
                    setLine2(resp.line2);
                    setDocTitle(resp.docTitle);
                    setAdmins(resp.admins)
                    setMembers(resp.members)
                    setActivities(resp.activities)
                    setActivityIdxToArchive([]);
                    const ctx = new SessionContext();
                    ctx.activities = resp.activities;
                    setDirty(false)
                    setComment('Zum Bearbeiten jeweils anklicken.')
                    break;
                }
            }
        }).catch(reason => {
            if ('name' in reason && reason.name === 'AbortError') {
                // expected
            } else {
                console.error('Unexpected error', reason)
                onLogoutClick();
            }
        }).finally(() => {
            setSpinning(false);
        })

    }, [onLogoutClick])

    useEffect(() => {
        // const w = scrollableContainerRef.current?.t
    })

    useEffect(() => {
        const abortController = abortControllerRef.current = new FixedAbortController();
        setGroupId(groupIdRef.current = decodeURIComponent(params.id))
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            setComment('Nicht eingeloggt.');
            return;
        }
        const id = Math.random();
        fetchData();

        return () => {
            abortController.abort()
        }
    }, [params.id, fetchData])

    function withSetDirty<T>(set: (t: T) => void) {
        return function (t: T) {
            set(t);
            setDirty(true)
        }
    }

    function onSave() {
        if (groupIdRef.current !== groupId) {
            if (confirm(`Änderung des Gruppennamens wird derzeit nicht unterstützt. Wieder zurücksetzen auf "${groupIdRef.current}"?`)) {
                setGroupId(groupIdRef.current)
            }
            return;
        }

        const [user1, token1] = userAndTokenFromStorages();

        if (user1 == null || token1 == null) {
            return;
        }

        if (groupId == null) throw new Error('groupId null?!');
        if (line1 == null) throw new Error('line1 null?!');
        if (line2 == null) throw new Error('line2 null?!');

        const req: GroupAdminGroupUpdateReq = {
            user: user1,
            token: token1,
            groupId: groupId,
            logo: logo,
            line1: line1,
            margin: margin,
            line2: line2,
            docTitle: docTitle,
            admins: admins,
            members: members,
            activities: activities,
            activityIdxToArchive: activityIdxToArchive
        }
        setSpinning(true)
        apiFetchPost<GroupAdminGroupUpdateReq, GroupAdminGroupUpdateResp>('/api/group-admin/group-update', req, abortControllerRef.current?.signal).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    onLogoutClick();
                    break;
                case 'success':
                    setDirty(false);
                    break;
                case 'error':
                    setComment(`Unerwarteter Fehler: ${resp.error}`);
                    break;
            }
        }).catch(reason => {
            if ('name' in reason && reason.name === 'AbortError') return;
            setComment(`Unerwarteter Fehler: ${JSON.stringify(reason)}`)
        }).finally(() => {
            setSpinning(false);
        })
    }

    function onDismiss() {
        if (confirm('Änderungen auf dieser Seite wirklich verwerfen und Daten neu laden?')) {
            fetchData()
        }
    }

    function onAddMember() {
        setAddingMember(true);
    }

    async function onMemberAdded({ group, newPhoneNr, prename, surname }: { group: string; newPhoneNr: string; prename: string; surname: string }) {
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            setMemberComment('Du bist nicht eingeloggt.')
            return;
        }
        const req: GroupAdminMemberAddReq = {
            user: user1,
            token: token1,
            groupId: group,
            phoneNr: newPhoneNr,
            prename: prename,
            surname: surname,
        }
        setMemberComment('');
        setAddingMember(false);
        setSpinning(true);
        try {
            const resp = await apiFetchPost<GroupAdminMemberAddReq, GroupAdminMemberAddResp>('/api/group-admin/member-add', req)
            switch (resp.type) {
                case 'authFailed':
                    setMemberComment('Nicht authorisiert.');
                    break;
                case 'success':
                    setMembers(resp.members)
                    break;
                case 'groupNotFound':
                    setMemberComment(`Gruppe ${group} existiert nicht.`);
                    break;
                case 'phoneNrContained':
                    setMemberComment(`Abgebrochen. Es gibt bereits ein Mitglied mit Telefonnr ${newPhoneNr} in Gruppe ${group}.`)
                    break;
                case 'error':
                    setMemberComment(`Unerwarteter Fehler: ${resp.error}`);
                    break;
            }
        } finally {
            setSpinning(false);
        }
    }

    const editMember = (idx: number) => () => {
        setEditedMemberIdx(idx)
        setEditedMember({
            ...members[idx]
        })
    }

    /**
     * only save the member temporarily. Will be finally saved on "Aenderungen speichern"
     * @returns 
     */
    function saveEditedMember() {
        if (editedMember == null) return;

        // new temporary saving:

        setMembers(members.map(member => editedMember.phoneNr === member.phoneNr ? editedMember : member));
        setEditedMemberIdx(null);
        setEditedMember(null);
        setDirty(true);


        // old final saving:
        // const ctx = new SessionContext();
        // const user1 = ctx.user;
        // const token1 = ctx.token;
        // if (user1 == null || token1 == null || groupIdRef.current == null) {
        //     setMemberComment('Nicht eingeloggt.');
        //     return;
        // }
        // const req: GroupAdminMemberUpdateReq = {
        //     user: user1,
        //     token: token1,
        //     groupId: groupIdRef.current,
        //     member: editedMember
        // }
        // setSpinning(true);
        // apiFetchPost<GroupAdminMemberUpdateReq, GroupAdminMemberUpdateResp>('/api/group-admin/member-update', req).then(resp => {
        //     switch (resp.type) {
        //         case 'authFailed':
        //             setComment('Nicht authorisiert.');
        //             break;
        //         case 'notFound':
        //             setComment('Nicht gefunden');
        //             break;
        //         case 'success':
        //             setEditedMemberIdx(null);
        //             setEditedMember(null);
        //             setMembers(resp.members);
        //             break;
        //         case 'error':
        //             setComment('Unerwarteter Fehler: ' + resp.error);
        //             break;
        //     }
        // }).catch(reason => {
        //     setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
        // }).finally(() => {
        //     setSpinning(false);
        // })
    }

    /**
     * only delete the edited member temporarily. Final deletion will be done on click on "Aenderungen speichern"
     * @returns 
     */
    function deleteEditedMember() {
        if (editedMember == null || groupId == null) return;

        // new temporary deletion:
        setMembers(members.filter(member => member.phoneNr !== editedMember.phoneNr));
        setEditedMemberIdx(null);
        setEditedMember(null);
        setDirty(true);


        // old final deletion:
        // const ctx = new SessionContext();
        // const user1 = ctx.user;
        // const token1 = ctx.token;
        // if (user1 == null || token1 == null) return;

        // if (confirm(`Mitglied mit Nr ${editedMember?.phoneNr} wirklich aus Gruppe ${groupId} ${(line1?.text || line2?.text) && `(${line1?.text} ${line1?.text && line2?.text && ' - '}${line2?.text})`} entfernen?`)) {
        //     const req: GroupAdminMemberDeleteReq = {
        //         user: user1,
        //         token: token1,
        //         groupId: groupId,
        //         phoneNr: editedMember.phoneNr
        //     }
        //     setSpinning(true);
        //     apiFetchPost<GroupAdminMemberDeleteReq, GroupAdminMemberDeleteResp>('/api/group-admin/member-delete', req, abortControllerRef.current?.signal).then(resp => {
        //         switch (resp.type) {
        //             case 'authFailed':
        //                 setComment('Nicht authorisiert.');
        //                 break;
        //             case 'success':
        //                 setMembers(members.filter(m => m.phoneNr !== editedMember?.phoneNr))
        //                 setEditedMemberIdx(null);
        //                 setEditedMember(null);
        //                 break;
        //             case 'error':
        //                 setComment(`Unerwarteter Fehler: ${resp.error}`);
        //                 break;
        //         }
        //     }).finally(() => {
        //         setSpinning(false)
        //     })
        // }
    }

    const updateActivity = useCallback((i: number, attr: string) => <T,>(t: T) => {
        setActivities(d => d.map((a, j) => (
            j === i ? ({
                ...a,
                [attr]: t
            }) : a
        )))
        setDirty(true);
    }, [])

    const deleteActivity = useCallback((i: number) => () => {
        setActivities(activities => activities.filter((a, j) => i !== j))
        setActivityIdxToArchive(old => {
            const a: number[] = [];
            old.forEach(j => {
                if (j < i) a.push(j);
                else if (j > i) a.push(j - 1);
            })
            return a;
        })
        setDirty(true)
    }, [])

    const archiveActivity = useCallback((i: number) => () => {
        setActivityIdxToArchive(old => [...old, i])
        setDirty(true);
    }, [])

    const addActivity = useCallback(() => {
        setActivities(activities => [...activities, {
            creationDate: null,
            name: 'Unbenannte Aktivität',
            date: null,
            capacity: null,
            participations: [],

        }])
        setDirty(true);
        setTimeout(() => {
            if (activityScrollableRef.current != null) {
                activityScrollableRef.current.scrollTo({
                    top: activityScrollableRef.current.scrollHeight,
                    behavior: 'smooth'
                })
            }

        })
    }, [])

    const addAdmin = useCallback(() => {
        const newAdmin = window.prompt('Enter the user name of the admin to add to this group.');
        if (newAdmin != null) {
            setAdmins(admins => [...admins, newAdmin]);
            setDirty(true);
        }
    }, [])

    const deleteAdmin = (admin: string) => () => {
        setAdmins(admins => admins.filter(a => a !== admin));
        setDirty(true);
    }

    const customMenuItems: CustomMenuItem[] = [
        {
            label: {
                label: 'LAYOUT FÜR DESKTOP', src: '/edit_12000664.png', alt: 'EDIT', width: 32, height: 32
            },
            onClick: () => router.push(`/group-admin/group/${params.id}`)
        },
        // {
        //     label: `${user} abmelden`,
        //     onClick() {
        //         alert('NYI');
        //     }
        // },
        ...(user == null ? [] : [{
            label: `${user} abmelden`,
            onClick: onLogoutClick
        }])
    ]

    return (
        <Menu
            onDeleteMemberClick={null} group={null}
            customItems={customMenuItems}
            customSpinning={spinning}
            setCookiesAccepted={setCookiesAccepted}
        >
            {cookiesAccepted && groupId != null &&
                <>
                    <Header
                        user={null}
                        line1={{ text: 'pr-groups / Gruppenadmin', fontSize: '1.2rem', bold: false }}
                        margin='1rem'
                        line2={{ text: groupId ?? '', fontSize: '1.5rem', bold: true }}
                    />
                    <div ref={mainRef} className={styles.main}>
                        <ScrollableContainer className={styles.scrollableContainer} points snap={horPage} setSnap={(i) => { setHorPage(i) }} snapOffset={0} >
                            <div className={styles.page}>
                                <div className={`scrollable ${styles.groupData}`}>

                                    <p>{comment}</p>
                                    <EditableImg label='Logo' img={logo} setImg={withSetDirty(setLogo)} />
                                    <Editable label='Gruppenname'
                                        info='Achtung! Wenn der Gruppenname geändert wird, ändern sich auch die Links für die Gruppenmitglieder, welche dann neu verschickt werden müssen.'
                                        value={groupId} setValue={withSetDirty(setGroupId)} format={id<string>} parse={(s) => s.length <= MAX_GROUP_LENGTH ? Promise.resolve(s) : Promise.reject(`Gruppenname max. ${MAX_GROUP_LENGTH} Zeichen!`)} />
                                    <HeaderLine label='Überschrift 1' line={line1 ?? { text: '', fontSize: '1rem', bold: false }} setLine={withSetDirty(setLine1)} />
                                    <Editable label='Abstand zwischen Überschrift 1 und Überschrift 2'
                                        value={margin} setValue={withSetDirty(setMargin)} format={id<string>} parse={(s) => {
                                            if (myCssSupports('margin', s)) {
                                                return Promise.resolve(s)
                                            } else {
                                                return Promise.reject('Ungültiger CSS-Wert für margin')
                                            }
                                        }}
                                    />
                                    <HeaderLine label='Überschrift 2' line={line2 ?? { text: '', fontSize: '1rem', bold: false }} setLine={withSetDirty(setLine2)} />
                                    <Checkbox label='Titel in Browser-Tab' checked={docTitle != null} setChecked={withSetDirty((b) => {
                                        if (b) {
                                            setDocTitle(lastDocTitle);
                                        } else {
                                            if (docTitle == null) {
                                                throw new Error('docTitle null');
                                            }
                                            setLastDocTitle(docTitle);
                                            setDocTitle(null);
                                        }
                                    })} />
                                    {docTitle != null &&
                                        <Editable label='Titel in Browser-Tab' value={docTitle} setValue={withSetDirty(setDocTitle)} format={id<string>} parse={(s) => s.length === 0 ? Promise.reject(`Kein leerer Titel!`) : s.length > MAX_DOC_TITLE_LENGTH ? Promise.reject(`Max. ${MAX_DOC_TITLE_LENGTH} Zeichen!`) : Promise.resolve(s)} />
                                    }
                                </div>
                            </div>
                            <div className={styles.page}>
                                <h3>Mitglieder</h3>
                                {comment && <p>{comment}</p>}
                                {memberComment && <p>{memberComment}</p>}
                                <button className={`${styles.clickable} ${styles.addButton}`} onClick={onAddMember}>Mitglied hinzufügen</button>
                                {/* <div className={`${styles.clickable} ${styles.add}`} onClick={onAddMember}><Image alt='Mitglied hinzufügen' src='/square_14034302.png' width={32} height={32} /><div className={styles.imgLabel}>Mitglied hinzufügen</div></div> */}
                                <p className={styles.lightHint}>Zum Bearbeiten Name anklicken</p>
                                <div className={`scrollable ${styles.box}`}>
                                    {
                                        members.map((m, i) => {
                                            const link = location.origin + invitationLink(groupId ?? '<FEHLER>', m)
                                            return (
                                                <div key={m.phoneNr}>
                                                    <hr className={styles.hr}></hr>
                                                    <div className={styles.memberPhoneNr}>
                                                        {m.phoneNr}
                                                    </div>
                                                    <div className={styles.memberName} tabIndex={0} onClick={editMember(i)}>
                                                        {m.prename} {m.surname}
                                                    </div>
                                                    <div className={styles.memberLinkLabel}>Einladungslink</div>
                                                    <div className={styles.memberLink}>
                                                        <a style={{/* maxWidth: '100%', */ overflow: 'auto', display: 'block' }} href={location.origin + invitationLink((groupId ?? '<FEHLER>'), m)}>{location.origin + invitationLink(groupId ?? '<FEHLER>', m)}</a>
                                                    </div>
                                                    <button className={styles.whatsApp} onClick={() => {
                                                        window.open(whatsappLink(m.phoneNr, `Hallo ${m.prename}, hier ist dein persönlicher Einladungslink für die Gruppe ${groupId} (${line1?.text}):\n\n${link}\n\n(Dieser Link ersetzt die Anmeldung mit Benutzername und Passwort, ist also nur speziell für dich und sollte nicht weiter gegeben werden.)`))
                                                    }}>{m.prename} {m.surname} einladen</button>
                                                </div>
                                            )
                                        })
                                    }
                                </div>
                            </div>
                            <div className={styles.page}>
                                <h3>Aktivitäten</h3>

                                <div ref={activityScrollableRef} className={`scrollable ${styles.activities}`}>
                                    {activities.map((a, i) =>
                                        !activityIdxToArchive.includes(i) && <ActivityComp key={i} i={i} a={a}
                                            updateName={updateActivity(i, 'name')}
                                            updateDate={updateActivity(i, 'date')}
                                            updateCapacity={updateActivity(i, 'capacity')}
                                            onDelete={deleteActivity(i)}
                                            onArchive={archiveActivity(i)} />
                                    )}
                                    <button className={`${styles.clickable} ${styles.addButton}`} onClick={addActivity}>Aktivität hinzufügen</button>
                                </div>
                            </div>

                            <div className={styles.page}>
                                <h3>Gruppen-Admins</h3>
                                <div className={`scrollable ${styles.admins}`}>
                                    {
                                        admins.map((a, i) => (
                                            <div key={a}>
                                                <div /* className={styles.row} */>
                                                    <Content>{a}</Content>
                                                    <button className={styles.delete} onClick={deleteAdmin(a)}>Delete</button>
                                                </div>
                                                <hr />
                                            </div>
                                        ))
                                    }
                                </div>
                                <button className={`${styles.clickable} ${styles.addButton}`} onClick={addAdmin}>Gruppen-Admin hinzufügen</button>
                            </div>
                        </ScrollableContainer>
                        <div className={styles.bottomBar}>
                            {dirty &&
                                <>
                                    <button className={styles.clickable} onClick={onSave}>ÄNDERUNGEN SPEICHERN</button>
                                    <button className={styles.clickable} onClick={onDismiss}>ÄNDERUNGEN VERWERFEN</button>
                                </>
                            }
                        </div>
                    </div>
                </>
            }
            <Popup visible={user == null} >
                <LoginComp user={userText} setUser={setUserText} passwd={passwdText} setPasswd={setPasswdText} onLoginClick={onLoginClick} comment={loginError} spinning={loginLogoutSpinning} />
            </Popup>
            {groupId != null &&
                <Popup visible={addingMember} >
                    <MemberAdd initialGroup={groupId} onAdd={onMemberAdded} onCancel={() => { setAddingMember(false) }} />
                </Popup>
            }
            <Popup visible={editedMember != null} >
                <h3>{editedMember?.phoneNr} bearbeiten</h3>
                <div className={styles.column}>
                    <Input label='Vorname' text={editedMember?.prename ?? ''} setText={t => {
                        if (editedMember != null) setEditedMember({
                            ...editedMember,
                            prename: t
                        })
                    }} />
                    <Input label='Nachname' text={editedMember?.surname ?? ''} setText={t => {
                        if (editedMember != null) setEditedMember({
                            ...editedMember,
                            surname: t
                        })
                    }} />

                    <div className={styles.buttonRow}>
                        <button onClick={saveEditedMember}>SPEICHERN</button>
                        <button onClick={() => {
                            setEditedMemberIdx(null); setEditedMember(null);
                        }}>ABBRECHEN</button>
                    </div>
                    <div >
                        <button onClick={deleteEditedMember} className={styles.delete}>LÖSCHEN</button>
                    </div>
                </div>
            </Popup>
        </Menu>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/group-admin/group-m/[id]/edit/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/group-admin/group-m/[id]/edit/page.tsx
fileSize: 668
replaced:
'use client'

import Header from "@/app/_lib/Header";
import Menu from "@/app/_lib/Menu";
import useUser from "@/app/_lib/useUser";
import { useState } from "react";

export default function Page() {
    const user = useUser();

    const [groupId, setGroupId] = useState('');

    return (
        <Menu onDeleteMemberClick={null} setCookiesAccepted={() => {}} >
            <Header
                user={user}
                line1={{ text: 'pr-groups / Gruppenadmin', fontSize: '1.2rem', bold: false }}
                margin='1rem'
                line2={{ text: groupId ?? '', fontSize: '1.5rem', bold: true }}
            />
            

        </Menu>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/group-admin/all-activities/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/group-admin/all-activities/page.tsx
fileSize: 12621
replaced:
'use client'

import { ActivitiesInGroup, Activity, GroupAdminAllGroupsActivitiesReq, GroupAdminAllGroupsActivitiesResp, Member, Participation } from "@/app/_lib/api"
import FixedAbortController from "@/app/_lib/pr-client-utils/FixedAbortController";
import { apiFetchPost } from "@/app/_lib/user-management-client/apiRoutesClient";
import { formatDateTime } from "@/app/_lib/utils";
import { useCallback, useEffect, useRef, useState } from "react"
import styles from './page.module.css'
import { Popup } from "@/app/Popup";
import LoginComp from "@/app/_lib/user-management-client/LoginComp";
import Menu, { CustomMenuItem } from "@/app/_lib/Menu";
import { LocalContext } from "@/app/_lib/LocalContext";
import { userAndTokenFromStorages } from "@/app/_lib/userAndToken";
import { useRouter } from "next/navigation";
import ActivityDetailsComp from "@/app/_lib/ActivityDetailsComp";
import useLoginLogout from "@/app/_lib/useLoginLogout";

interface Details {
    group: string;
    members: Member[];
    activity: Activity;
}

interface ActivityProps {
    group: string;
    members: Member[];
    activity: Activity;
    setDetails: (details: Details | null) => void;
}
function ActivityComp({ group, members, activity, setDetails }: ActivityProps) {
    function onDetails() {
        setDetails({ group, activity, members });
    }
    let accepting: string[] = []
    let rejecting: string[] = [];
    activity.participations.forEach(p => {
        switch (p.accept) {
            case 'accepted':
                if (!accepting.includes(p.phoneNr)) {
                    accepting.push(p.phoneNr);
                }
                rejecting = rejecting.filter(phoneNr => phoneNr !== p.phoneNr)
                break;

            case 'rejected':
                accepting = accepting.filter(phoneNr => phoneNr !== p.phoneNr);
                if (!rejecting.includes(p.phoneNr)) {
                    rejecting.push(p.phoneNr);
                }
                break;

            case 'undecided':
                accepting = accepting.filter(phoneNr => phoneNr !== p.phoneNr);
                rejecting = rejecting.filter(phoneNr => phoneNr !== p.phoneNr)
                break;
        }
    })
    return (
        <div className={styles.activity}>
            <div>{activity.name}</div>
            <div className={styles.date}>{formatDateTime(activity.date, true)}</div>
            <div><a tabIndex={0} onClick={onDetails} onKeyUp={(e) => { if (e.key === 'Enter' || e.key === ' ') onDetails(); }}>{accepting.length} / {activity.capacity ?? 'unbegrenzt'}</a></div>
        </div>
    )
}

interface ActivitiesInGroupProps {
    activitiesInGroup: ActivitiesInGroup;
    setDetails: (d: Details | null) => void;
    onEdit: () => void;
}
function ActivitiesInGroupComp({ activitiesInGroup, setDetails, onEdit }: ActivitiesInGroupProps) {
    return (
        <div className={styles.group}>
            <div className={styles.groupHeader}>
                <div>{activitiesInGroup.groupTitle} <span className={styles.groupId}>#{activitiesInGroup.group}</span></div>
                <button className={styles.edit} onClick={onEdit}>{/* <Image src='/edit_12000664.png' alt='Edit' width={32} height={32} /> */}</button>
            </div>
            <div className={styles.activities}>
                {
                    activitiesInGroup.activities.map((a, i) => (
                        <ActivityComp key={i} group={activitiesInGroup.groupTitle ?? activitiesInGroup.group} members={activitiesInGroup.members} activity={a} setDetails={setDetails} />))
                }
            </div>
        </div>
    )
}

export default function Page() {
    const [comment, setComment] = useState('')
    const [activitiesInGroups, setActivitiesInGroups] = useState<ActivitiesInGroup[] | null>(null);
    const [details, setDetails] = useState<Details | null>(null);
    // const [login, setLogin] = useState(false);
    const [spinning, setSpinning] = useState(true);
    const abortControllerRef = useRef<AbortController | null>(null);
    const [cookiesAccepted, setCookiesAccepted] = useState(false);
    const [asStartPage, setAsStartPage] = useState(false);

    const [user, onLoginClick, onLogoutClick, loginLogoutSpinning, userText, setUserText, passwdText, setPasswdText, loginError, logoutError] = useLoginLogout()

    const fetch = useCallback(() => {
        setComment('');
        const [user1, token1] = userAndTokenFromStorages();
        if (user1 == null || token1 == null) {
            setComment('Nicht authorisiert.');
            return;
        }

        const req: GroupAdminAllGroupsActivitiesReq = {
            user: user1,
            token: token1
        }
        setSpinning(true);
        apiFetchPost<GroupAdminAllGroupsActivitiesReq, GroupAdminAllGroupsActivitiesResp>('/api/group-admin/all-activities', req, abortControllerRef.current?.signal).then(resp => {
            switch (resp.type) {
                case 'authFailed':
                    setComment('Nicht authorisiert.');
                    onLogoutClick();
                    // setLogin(true);
                    break;
                case 'error':
                    setComment('Unerwarteter Fehler: ' + resp.error);
                    break;
                case 'success':
                    setActivitiesInGroups(resp.activitiesInGroups.toSorted((a, b) => a.group.localeCompare(b.group)).map(aig => ({
                        ...aig,
                        activities: aig.activities.toSorted((a, b) => (a.date == null ? (b.date == null ? 0 : 1) : (b.date == null ? -1 : a.date - b.date)))
                    })))
                    // setLogin(false);
                    break;
            }
        }).catch(reason => {
            if ('name' in reason && reason.name === 'AbortError') {
                // ignore
            } else {
                setComment('Unerwarteter Fehler: ' + JSON.stringify(reason));
            }
        }).finally(() => {
            setSpinning(false)
        })

    }, [onLogoutClick])

    const router = useRouter();

    useEffect(() => {
        if (!cookiesAccepted) return;
        const ctx = new LocalContext()
        setAsStartPage(ctx.allActivitiesAsStartPage);
        abortControllerRef.current = new FixedAbortController();
        if (user != null) {
            fetch()
        }
        return () => {
            abortControllerRef.current?.abort();
        }
    }, [fetch, cookiesAccepted, user])


    const decisions: { [user: string]: Participation } | undefined = details?.activity.participations.reduce((d, participation) => ({
        ...d,
        [participation.phoneNr]: participation
    }),
        {}
    )

    const accept: Participation[] = decisions == null ? [] : Object.values(decisions).filter((p => p.accept === 'accepted'))
    const reject: Participation[] = decisions == null ? [] : Object.values(decisions).filter((p => p.accept === 'rejected'))
    const undecided: string[] = details == null ? [] : (details?.members.map(member => member.phoneNr).filter(phoneNr => !accept.map(p => p.phoneNr).includes(phoneNr) && !reject.map(p => p.phoneNr).includes(phoneNr)))

    function phoneNrToName(phoneNr: string): string {
        if (details == null) return '';
        const member = details.members.find(member => member.phoneNr === phoneNr)
        if (member == null) return '';
        return member.prename + ' ' + member.surname;
    }

    const customMenuItems: CustomMenuItem[] = [
        {
            type: 'checkbox',
            label: 'Diese Seite als Startseite nach dem Login',
            checked: asStartPage,
            setChecked(checked: boolean) {
                setAsStartPage(checked)
                const ctx = new LocalContext();
                ctx.allActivitiesAsStartPage = checked;
            }
        },
        ...(user == null ? [] : [({
            label: `${user} abmelden`,
            onClick: onLogoutClick
        })])
    ]

    return (
        <>
            <Menu customSpinning={spinning || loginLogoutSpinning} setCookiesAccepted={setCookiesAccepted} customItems={customMenuItems} />
            <div className={styles.main}>
                <p>{comment}</p>
                <Popup visible={/* login */ user == null} >
                    <LoginComp user={userText} setUser={setUserText} passwd={passwdText} setPasswd={setPasswdText} onLoginClick={onLoginClick} comment={loginError} spinning={loginLogoutSpinning} />
                </Popup>
                {
                    activitiesInGroups &&
                    activitiesInGroups.map(activitiesInGroup => <ActivitiesInGroupComp key={activitiesInGroup.group} activitiesInGroup={activitiesInGroup} setDetails={setDetails} onEdit={() => {
                        router.push(`/group-admin/group-m/${activitiesInGroup.group}`)
                    }} />)
                }
                {
                    (!spinning || loginLogoutSpinning) && (!activitiesInGroups || activitiesInGroups.length === 0) &&
                    <p className={styles.empty}>Deinem Benutzerkonto sind (noch?) keine Gruppen und Aktivitäten zugeordnet.</p>
                }
            </div>
            <Popup visible={details != null} setVisible={(visible) => {
                if (!visible) setDetails(null)
            }}>
                <ActivityDetailsComp group={details?.group ?? ''} members={details?.members ?? []} selActivity={details?.activity ?? null} />
                {/* <h2 className={styles.headerActivity}>{details?.activity.name} {details?.activity.date != null && formatDateTime(details?.activity.date, true)}</h2>
                <div className={styles.detailLists}>
                    <h3 className={styles.headerAccepts}>{accept.length} Zusagen</h3>
                    <div>
                        {
                            accept.length === 0 ? <span className={styles.none}>keine</span> :
                                <table>
                                    <tbody>

                                        {
                                            accept.map((participation, i) => (
                                                <tr key={i}>
                                                    <td className={styles.detailName}>{phoneNrToName(participation.phoneNr)}</td>
                                                    <td><WhatsAppLinkComp phoneNr={participation.phoneNr} /></td>
                                                    <td className={styles.detailDate}>{formatDateTime(new Date(participation.date))}</td>
                                                </tr>))
                                        }

                                    </tbody>
                                </table>
                        }
                    </div>
                    <h3 className={styles.headerRejects}>{reject.length} Absagen</h3>
                    <div>
                        {
                            reject.length === 0 ? <span className={styles.none}>keine</span> :
                                <table>
                                    <tbody>

                                        {
                                            reject.map((participation, i) => (
                                                <tr key={i}>
                                                    <td className={styles.detailName}>{phoneNrToName(participation.phoneNr)}</td>
                                                    <td><WhatsAppLinkComp phoneNr={participation.phoneNr} /></td>
                                                    <td className={styles.detailDate}>{formatDateTime(new Date(participation.date))}</td>
                                                </tr>))
                                        }

                                    </tbody>
                                </table>
                        }

                    </div>
                    <h3 className={styles.headerUndecided}>{undecided.length} haben noch nicht abgestimmt oder können es noch nicht sagen:</h3>
                    <table>
                        <tbody>
                            {
                                undecided.map((phoneNr, i) => <tr key={i}>
                                    <td className={styles.detailName}>{phoneNrToName(phoneNr)}</td>
                                    <td><WhatsAppLinkComp phoneNr={phoneNr} /></td>
                                </tr>)
                            }
                        </tbody>
                    </table>
                </div> */}

            </Popup>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/testTabs/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/testTabs/page.tsx
fileSize: 1036
replaced:
'use client'
import { useState } from 'react'
import TabButton from '../_lib/TabButton'
import styles from './page.module.css'
import TabPage from '../_lib/TabPage';
export default function Page() {
    const [sel, setSel] = useState('1');
    return (
        <div>
            <div className={styles.buttonRow}>
                <TabButton label='1' ownKey='1' selectedKey={sel} setSelectedKey={setSel} />
                <TabButton label='2' ownKey='2' selectedKey={sel} setSelectedKey={setSel} />
                <TabButton label='3' ownKey='3' selectedKey={sel} setSelectedKey={setSel} />
            </div>
            <div className={styles.container}>
                <TabPage ownKey='1' selectedKey={sel}>
                    Content 1
                </TabPage>
                <TabPage ownKey='2' selectedKey={sel}>
                    Content 2
                </TabPage>
                <TabPage ownKey='3' selectedKey={sel}>
                    Content 3
                </TabPage>
            </div>
        </div>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/register/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/register/page.tsx
fileSize: 3339
replaced:
'use client'

import { useEffect, useRef, useState } from 'react'
import styles from './page.module.css'
import { userRegisterFetch } from '../_lib/user-management-client/userManagementClient';
import { RegisterReq } from '../_lib/user-management-client/user-management-common/register';
import { useRouter } from 'next/navigation';
import Header from '../_lib/Header';
import Input from '../_lib/Input';
import Input2 from '../_lib/pr-client-utils/Input2';
import FormComp from '../_lib/pr-client-utils/FormComp';
import Menu from '../_lib/Menu';
import { register } from '../_lib/userAndToken';
import FixedAbortController from '../_lib/pr-client-utils/FixedAbortController';
import { isAbortError } from '../_lib/utils';

const validateUser = (text: string) => text === '' ? 'User erforderlich!' : '';
const validatePasswdRepeat = (passwd: string) => (text: string) => text !== passwd ? 'Passwörter stimmen nicht überein!' : '';

export default function Page() {
    const [user, setUser] = useState('');
    const [passwd, setPasswd] = useState('');
    const [passwdRepeat, setPasswdRepeat] = useState('');
    const [cookiesAccepted, setCookiesAccepted] = useState(false);
    const abortControllerRef = useRef<AbortController | null>(null);

    const router = useRouter();

    useEffect(() => {
        abortControllerRef.current = new FixedAbortController();
        return () => {
            abortControllerRef.current?.abort();
        }
    }, [])

    function onRegisterClick() {
        if (validateUser(user) !== '' || validatePasswdRepeat(passwd)(passwdRepeat) !== '') {
            alert('Bitte Eingaben überprüfen!');
            return;
        }
        register(user, passwd, abortControllerRef.current?.signal).then(error => {
            if (error) {
                alert(error)
            } else {
                alert(`User ${user} erfolgreich registriert.`);
                router.push('/login');
            }
        }).catch((reason: any) => {
            if (isAbortError(reason)) {
                // ignore
            } else {
                alert('Unerwarteter Fehler: ' + JSON.stringify(reason));
            }
        })
    }

    return (
        <>
            <Menu setCookiesAccepted={setCookiesAccepted} />
            {/* <Header user={user} line1={{ text: '', fontSize: '1.2rem', bold: false }} margin='1rem' line2={{ text: '', fontSize: '1.5rem', bold: true }} /> */}
            <div className={styles.main}>
                <h1>pr-groups</h1>
                <FormComp decoImg={{ src: '/group-friends-jumping-top-hill.jpg', alt: 'Gruppe', width: 714, height: 576 }} maxWidth={1200} >
                    <div className={styles.innerForm}>
                        <h1>Konto erstellen</h1>
                        <Input2 label='User' type='text' text={user} setText={setUser} validate={validateUser} />
                        <Input2 type='password' label='Passwort' text={passwd} setText={setPasswd} />
                        <Input2 type='password' label='Passwort wiederholen' text={passwdRepeat} setText={setPasswdRepeat} validate={validatePasswdRepeat(passwd)} />
                        <button className={styles.registerButton} onClick={onRegisterClick}>Konto erstellen</button>
                    </div>
                </FormComp>
            </div>
        </>
    )
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/forms/layout.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/forms/layout.tsx
fileSize: 198
replaced:

export default function Layout({ children }: { children: React.ReactNode }) {

    return <div className='wrapper'>
        <div className='form'>
            {children}
        </div>
    </div>
}

path: "/home/peter/my_projects/individual-gits/pr-groups/app/forms/testForm/page.tsx"
Should operate now /home/peter/my_projects/individual-gits/pr-groups/app/forms/testForm/page.tsx
fileSize: 1891
replaced:
'use client'

import Input2 from "@/app/_lib/pr-client-utils/Input2";
import { useCallback, useRef, useState } from "react";

import styles from './page.module.css'

export default function Page() {
    const [text, setText] = useState('');
    const [passwd, setPasswd] = useState('');
    function wrapSetText(t: string) {
        setText(t);
    }
    const validateUser = useCallback((user: string) => {
        return user.length < 3 ? 'At least 3 characters!' : '';
    }, [])

    const validatePasswd = useCallback((passwd: string): string => {
        return passwd.length < 8 ? 'At least 8 characters!' : '';
    }, [])
    const validateNumber = useCallback((s: string) => {
        const n = Number.parseInt(s)
        const res = (n < 1 || n > 10) ? 'not between 1 and 10' : isNaN(n) ? 'no number' : ''
        console.log('validateNumber', n, res);
        return res
    }, [])
    return (
        <>
            <h1>testForm</h1>
            <div className={styles.testBorder}>
                <Input2 label='User' text={text} setText={setText} comment='OK' commentClass={styles.comment1} validate={validateUser} />
                <Input2 label='Passwort' type='password' text={passwd} setText={setPasswd} comment='Use lowercase, uppercase letters and digits' validate={validatePasswd} />
                <Input2 label='date' type='date' text={text} setText={setText} />
                <Input2 label='month' type='month' text={text} setText={setText} />
                <Input2 label='week' type='week' text={text} setText={setText} />
                <Input2 label='datetime-local' type='datetime-local' text={text} setText={setText} />
                <Input2 label='email' type='email' text={text} setText={setText} />
                <Input2 label='number' type='number' text={text} setText={setText} validate={validateNumber} />
            </div>
        </>
    )
}

